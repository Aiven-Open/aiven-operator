//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Copyright (c) 2022 Aiven, Helsinki, Finland. https://aiven.io/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	cassandra "github.com/aiven/aiven-operator/api/v1alpha1/userconfigs/cassandra"
	grafana "github.com/aiven/aiven-operator/api/v1alpha1/userconfigs/grafana"
	kafka "github.com/aiven/aiven-operator/api/v1alpha1/userconfigs/kafka"
	mysql "github.com/aiven/aiven-operator/api/v1alpha1/userconfigs/mysql"
	pg "github.com/aiven/aiven-operator/api/v1alpha1/userconfigs/pg"
	"k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthSecretReference) DeepCopyInto(out *AuthSecretReference) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthSecretReference.
func (in *AuthSecretReference) DeepCopy() *AuthSecretReference {
	if in == nil {
		return nil
	}
	out := new(AuthSecretReference)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Cassandra) DeepCopyInto(out *Cassandra) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Cassandra.
func (in *Cassandra) DeepCopy() *Cassandra {
	if in == nil {
		return nil
	}
	out := new(Cassandra)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Cassandra) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CassandraList) DeepCopyInto(out *CassandraList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Cassandra, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CassandraList.
func (in *CassandraList) DeepCopy() *CassandraList {
	if in == nil {
		return nil
	}
	out := new(CassandraList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CassandraList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CassandraSpec) DeepCopyInto(out *CassandraSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = new(cassandra.CassandraUserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CassandraSpec.
func (in *CassandraSpec) DeepCopy() *CassandraSpec {
	if in == nil {
		return nil
	}
	out := new(CassandraSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Clickhouse) DeepCopyInto(out *Clickhouse) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Clickhouse.
func (in *Clickhouse) DeepCopy() *Clickhouse {
	if in == nil {
		return nil
	}
	out := new(Clickhouse)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Clickhouse) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseList) DeepCopyInto(out *ClickhouseList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Clickhouse, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseList.
func (in *ClickhouseList) DeepCopy() *ClickhouseList {
	if in == nil {
		return nil
	}
	out := new(ClickhouseList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClickhouseList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseSpec) DeepCopyInto(out *ClickhouseSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	in.UserConfig.DeepCopyInto(&out.UserConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseSpec.
func (in *ClickhouseSpec) DeepCopy() *ClickhouseSpec {
	if in == nil {
		return nil
	}
	out := new(ClickhouseSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseUser) DeepCopyInto(out *ClickhouseUser) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseUser.
func (in *ClickhouseUser) DeepCopy() *ClickhouseUser {
	if in == nil {
		return nil
	}
	out := new(ClickhouseUser)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClickhouseUser) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseUserConfig) DeepCopyInto(out *ClickhouseUserConfig) {
	*out = *in
	if in.IpFilter != nil {
		in, out := &in.IpFilter, &out.IpFilter
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseUserConfig.
func (in *ClickhouseUserConfig) DeepCopy() *ClickhouseUserConfig {
	if in == nil {
		return nil
	}
	out := new(ClickhouseUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseUserList) DeepCopyInto(out *ClickhouseUserList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClickhouseUser, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseUserList.
func (in *ClickhouseUserList) DeepCopy() *ClickhouseUserList {
	if in == nil {
		return nil
	}
	out := new(ClickhouseUserList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClickhouseUserList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseUserSpec) DeepCopyInto(out *ClickhouseUserSpec) {
	*out = *in
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseUserSpec.
func (in *ClickhouseUserSpec) DeepCopy() *ClickhouseUserSpec {
	if in == nil {
		return nil
	}
	out := new(ClickhouseUserSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseUserStatus) DeepCopyInto(out *ClickhouseUserStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseUserStatus.
func (in *ClickhouseUserStatus) DeepCopy() *ClickhouseUserStatus {
	if in == nil {
		return nil
	}
	out := new(ClickhouseUserStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnInfoSecretTarget) DeepCopyInto(out *ConnInfoSecretTarget) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnInfoSecretTarget.
func (in *ConnInfoSecretTarget) DeepCopy() *ConnInfoSecretTarget {
	if in == nil {
		return nil
	}
	out := new(ConnInfoSecretTarget)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPool) DeepCopyInto(out *ConnectionPool) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPool.
func (in *ConnectionPool) DeepCopy() *ConnectionPool {
	if in == nil {
		return nil
	}
	out := new(ConnectionPool)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ConnectionPool) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPoolList) DeepCopyInto(out *ConnectionPoolList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ConnectionPool, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPoolList.
func (in *ConnectionPoolList) DeepCopy() *ConnectionPoolList {
	if in == nil {
		return nil
	}
	out := new(ConnectionPoolList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ConnectionPoolList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPoolSpec) DeepCopyInto(out *ConnectionPoolSpec) {
	*out = *in
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPoolSpec.
func (in *ConnectionPoolSpec) DeepCopy() *ConnectionPoolSpec {
	if in == nil {
		return nil
	}
	out := new(ConnectionPoolSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPoolStatus) DeepCopyInto(out *ConnectionPoolStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPoolStatus.
func (in *ConnectionPoolStatus) DeepCopy() *ConnectionPoolStatus {
	if in == nil {
		return nil
	}
	out := new(ConnectionPoolStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Database) DeepCopyInto(out *Database) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Database.
func (in *Database) DeepCopy() *Database {
	if in == nil {
		return nil
	}
	out := new(Database)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Database) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseList) DeepCopyInto(out *DatabaseList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Database, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseList.
func (in *DatabaseList) DeepCopy() *DatabaseList {
	if in == nil {
		return nil
	}
	out := new(DatabaseList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DatabaseList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseSpec) DeepCopyInto(out *DatabaseSpec) {
	*out = *in
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseSpec.
func (in *DatabaseSpec) DeepCopy() *DatabaseSpec {
	if in == nil {
		return nil
	}
	out := new(DatabaseSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseStatus) DeepCopyInto(out *DatabaseStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseStatus.
func (in *DatabaseStatus) DeepCopy() *DatabaseStatus {
	if in == nil {
		return nil
	}
	out := new(DatabaseStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Grafana) DeepCopyInto(out *Grafana) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Grafana.
func (in *Grafana) DeepCopy() *Grafana {
	if in == nil {
		return nil
	}
	out := new(Grafana)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Grafana) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GrafanaList) DeepCopyInto(out *GrafanaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Grafana, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GrafanaList.
func (in *GrafanaList) DeepCopy() *GrafanaList {
	if in == nil {
		return nil
	}
	out := new(GrafanaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GrafanaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GrafanaSpec) DeepCopyInto(out *GrafanaSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = new(grafana.GrafanaUserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GrafanaSpec.
func (in *GrafanaSpec) DeepCopy() *GrafanaSpec {
	if in == nil {
		return nil
	}
	out := new(GrafanaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Kafka) DeepCopyInto(out *Kafka) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Kafka.
func (in *Kafka) DeepCopy() *Kafka {
	if in == nil {
		return nil
	}
	out := new(Kafka)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Kafka) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaACL) DeepCopyInto(out *KafkaACL) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaACL.
func (in *KafkaACL) DeepCopy() *KafkaACL {
	if in == nil {
		return nil
	}
	out := new(KafkaACL)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaACL) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaACLList) DeepCopyInto(out *KafkaACLList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaACL, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaACLList.
func (in *KafkaACLList) DeepCopy() *KafkaACLList {
	if in == nil {
		return nil
	}
	out := new(KafkaACLList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaACLList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaACLSpec) DeepCopyInto(out *KafkaACLSpec) {
	*out = *in
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaACLSpec.
func (in *KafkaACLSpec) DeepCopy() *KafkaACLSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaACLSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaACLStatus) DeepCopyInto(out *KafkaACLStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaACLStatus.
func (in *KafkaACLStatus) DeepCopy() *KafkaACLStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaACLStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnect) DeepCopyInto(out *KafkaConnect) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnect.
func (in *KafkaConnect) DeepCopy() *KafkaConnect {
	if in == nil {
		return nil
	}
	out := new(KafkaConnect)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConnect) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectList) DeepCopyInto(out *KafkaConnectList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaConnect, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectList.
func (in *KafkaConnectList) DeepCopy() *KafkaConnectList {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConnectList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectPrivateAccessUserConfig) DeepCopyInto(out *KafkaConnectPrivateAccessUserConfig) {
	*out = *in
	if in.KafkaConnect != nil {
		in, out := &in.KafkaConnect, &out.KafkaConnect
		*out = new(bool)
		**out = **in
	}
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectPrivateAccessUserConfig.
func (in *KafkaConnectPrivateAccessUserConfig) DeepCopy() *KafkaConnectPrivateAccessUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectPrivateAccessUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectPublicAccessUserConfig) DeepCopyInto(out *KafkaConnectPublicAccessUserConfig) {
	*out = *in
	if in.KafkaConnect != nil {
		in, out := &in.KafkaConnect, &out.KafkaConnect
		*out = new(bool)
		**out = **in
	}
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectPublicAccessUserConfig.
func (in *KafkaConnectPublicAccessUserConfig) DeepCopy() *KafkaConnectPublicAccessUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectPublicAccessUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectSpec) DeepCopyInto(out *KafkaConnectSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	in.UserConfig.DeepCopyInto(&out.UserConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectSpec.
func (in *KafkaConnectSpec) DeepCopy() *KafkaConnectSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectUserConfig) DeepCopyInto(out *KafkaConnectUserConfig) {
	*out = *in
	if in.ConsumerFetchMaxBytes != nil {
		in, out := &in.ConsumerFetchMaxBytes, &out.ConsumerFetchMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerMaxPartitionFetchBytes != nil {
		in, out := &in.ConsumerMaxPartitionFetchBytes, &out.ConsumerMaxPartitionFetchBytes
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerMaxPollIntervalMs != nil {
		in, out := &in.ConsumerMaxPollIntervalMs, &out.ConsumerMaxPollIntervalMs
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerMaxPollRecords != nil {
		in, out := &in.ConsumerMaxPollRecords, &out.ConsumerMaxPollRecords
		*out = new(int64)
		**out = **in
	}
	if in.OffsetFlushIntervalMs != nil {
		in, out := &in.OffsetFlushIntervalMs, &out.OffsetFlushIntervalMs
		*out = new(int64)
		**out = **in
	}
	if in.ProducerMaxRequestSize != nil {
		in, out := &in.ProducerMaxRequestSize, &out.ProducerMaxRequestSize
		*out = new(int64)
		**out = **in
	}
	if in.SessionTimeoutMs != nil {
		in, out := &in.SessionTimeoutMs, &out.SessionTimeoutMs
		*out = new(int64)
		**out = **in
	}
	in.PrivateAccess.DeepCopyInto(&out.PrivateAccess)
	in.PublicAccess.DeepCopyInto(&out.PublicAccess)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectUserConfig.
func (in *KafkaConnectUserConfig) DeepCopy() *KafkaConnectUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnector) DeepCopyInto(out *KafkaConnector) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnector.
func (in *KafkaConnector) DeepCopy() *KafkaConnector {
	if in == nil {
		return nil
	}
	out := new(KafkaConnector)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConnector) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorList) DeepCopyInto(out *KafkaConnectorList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaConnector, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorList.
func (in *KafkaConnectorList) DeepCopy() *KafkaConnectorList {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConnectorList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorPluginStatus) DeepCopyInto(out *KafkaConnectorPluginStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorPluginStatus.
func (in *KafkaConnectorPluginStatus) DeepCopy() *KafkaConnectorPluginStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorPluginStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorSpec) DeepCopyInto(out *KafkaConnectorSpec) {
	*out = *in
	out.AuthSecretRef = in.AuthSecretRef
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorSpec.
func (in *KafkaConnectorSpec) DeepCopy() *KafkaConnectorSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorStatus) DeepCopyInto(out *KafkaConnectorStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	out.PluginStatus = in.PluginStatus
	out.TasksStatus = in.TasksStatus
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorStatus.
func (in *KafkaConnectorStatus) DeepCopy() *KafkaConnectorStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorTasksStatus) DeepCopyInto(out *KafkaConnectorTasksStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorTasksStatus.
func (in *KafkaConnectorTasksStatus) DeepCopy() *KafkaConnectorTasksStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorTasksStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaList) DeepCopyInto(out *KafkaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Kafka, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaList.
func (in *KafkaList) DeepCopy() *KafkaList {
	if in == nil {
		return nil
	}
	out := new(KafkaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSchema) DeepCopyInto(out *KafkaSchema) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSchema.
func (in *KafkaSchema) DeepCopy() *KafkaSchema {
	if in == nil {
		return nil
	}
	out := new(KafkaSchema)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaSchema) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSchemaList) DeepCopyInto(out *KafkaSchemaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaSchema, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSchemaList.
func (in *KafkaSchemaList) DeepCopy() *KafkaSchemaList {
	if in == nil {
		return nil
	}
	out := new(KafkaSchemaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaSchemaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSchemaSpec) DeepCopyInto(out *KafkaSchemaSpec) {
	*out = *in
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSchemaSpec.
func (in *KafkaSchemaSpec) DeepCopy() *KafkaSchemaSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaSchemaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSchemaStatus) DeepCopyInto(out *KafkaSchemaStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSchemaStatus.
func (in *KafkaSchemaStatus) DeepCopy() *KafkaSchemaStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaSchemaStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSpec) DeepCopyInto(out *KafkaSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	if in.Karapace != nil {
		in, out := &in.Karapace, &out.Karapace
		*out = new(bool)
		**out = **in
	}
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = new(kafka.KafkaUserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSpec.
func (in *KafkaSpec) DeepCopy() *KafkaSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopic) DeepCopyInto(out *KafkaTopic) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopic.
func (in *KafkaTopic) DeepCopy() *KafkaTopic {
	if in == nil {
		return nil
	}
	out := new(KafkaTopic)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaTopic) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicConfig) DeepCopyInto(out *KafkaTopicConfig) {
	*out = *in
	if in.DeleteRetentionMs != nil {
		in, out := &in.DeleteRetentionMs, &out.DeleteRetentionMs
		*out = new(int64)
		**out = **in
	}
	if in.FileDeleteDelayMs != nil {
		in, out := &in.FileDeleteDelayMs, &out.FileDeleteDelayMs
		*out = new(int64)
		**out = **in
	}
	if in.FlushMessages != nil {
		in, out := &in.FlushMessages, &out.FlushMessages
		*out = new(int64)
		**out = **in
	}
	if in.FlushMs != nil {
		in, out := &in.FlushMs, &out.FlushMs
		*out = new(int64)
		**out = **in
	}
	if in.IndexIntervalBytes != nil {
		in, out := &in.IndexIntervalBytes, &out.IndexIntervalBytes
		*out = new(int64)
		**out = **in
	}
	if in.MaxCompactionLagMs != nil {
		in, out := &in.MaxCompactionLagMs, &out.MaxCompactionLagMs
		*out = new(int64)
		**out = **in
	}
	if in.MaxMessageBytes != nil {
		in, out := &in.MaxMessageBytes, &out.MaxMessageBytes
		*out = new(int64)
		**out = **in
	}
	if in.MessageDownconversionEnable != nil {
		in, out := &in.MessageDownconversionEnable, &out.MessageDownconversionEnable
		*out = new(bool)
		**out = **in
	}
	if in.MessageTimestampDifferenceMaxMs != nil {
		in, out := &in.MessageTimestampDifferenceMaxMs, &out.MessageTimestampDifferenceMaxMs
		*out = new(int64)
		**out = **in
	}
	if in.MinCompactionLagMs != nil {
		in, out := &in.MinCompactionLagMs, &out.MinCompactionLagMs
		*out = new(int64)
		**out = **in
	}
	if in.MinInsyncReplicas != nil {
		in, out := &in.MinInsyncReplicas, &out.MinInsyncReplicas
		*out = new(int64)
		**out = **in
	}
	if in.Preallocate != nil {
		in, out := &in.Preallocate, &out.Preallocate
		*out = new(bool)
		**out = **in
	}
	if in.RetentionBytes != nil {
		in, out := &in.RetentionBytes, &out.RetentionBytes
		*out = new(int64)
		**out = **in
	}
	if in.RetentionMs != nil {
		in, out := &in.RetentionMs, &out.RetentionMs
		*out = new(int64)
		**out = **in
	}
	if in.SegmentBytes != nil {
		in, out := &in.SegmentBytes, &out.SegmentBytes
		*out = new(int64)
		**out = **in
	}
	if in.SegmentIndexBytes != nil {
		in, out := &in.SegmentIndexBytes, &out.SegmentIndexBytes
		*out = new(int64)
		**out = **in
	}
	if in.SegmentJitterMs != nil {
		in, out := &in.SegmentJitterMs, &out.SegmentJitterMs
		*out = new(int64)
		**out = **in
	}
	if in.SegmentMs != nil {
		in, out := &in.SegmentMs, &out.SegmentMs
		*out = new(int64)
		**out = **in
	}
	if in.UncleanLeaderElectionEnable != nil {
		in, out := &in.UncleanLeaderElectionEnable, &out.UncleanLeaderElectionEnable
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicConfig.
func (in *KafkaTopicConfig) DeepCopy() *KafkaTopicConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicList) DeepCopyInto(out *KafkaTopicList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaTopic, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicList.
func (in *KafkaTopicList) DeepCopy() *KafkaTopicList {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaTopicList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicSpec) DeepCopyInto(out *KafkaTopicSpec) {
	*out = *in
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make([]KafkaTopicTag, len(*in))
		copy(*out, *in)
	}
	in.Config.DeepCopyInto(&out.Config)
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicSpec.
func (in *KafkaTopicSpec) DeepCopy() *KafkaTopicSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicStatus) DeepCopyInto(out *KafkaTopicStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicStatus.
func (in *KafkaTopicStatus) DeepCopy() *KafkaTopicStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicTag) DeepCopyInto(out *KafkaTopicTag) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicTag.
func (in *KafkaTopicTag) DeepCopy() *KafkaTopicTag {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicTag)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQL) DeepCopyInto(out *MySQL) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQL.
func (in *MySQL) DeepCopy() *MySQL {
	if in == nil {
		return nil
	}
	out := new(MySQL)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *MySQL) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLList) DeepCopyInto(out *MySQLList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]MySQL, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLList.
func (in *MySQLList) DeepCopy() *MySQLList {
	if in == nil {
		return nil
	}
	out := new(MySQLList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *MySQLList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLSpec) DeepCopyInto(out *MySQLSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = new(mysql.MysqlUserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLSpec.
func (in *MySQLSpec) DeepCopy() *MySQLSpec {
	if in == nil {
		return nil
	}
	out := new(MySQLSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearch) DeepCopyInto(out *OpenSearch) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearch.
func (in *OpenSearch) DeepCopy() *OpenSearch {
	if in == nil {
		return nil
	}
	out := new(OpenSearch)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OpenSearch) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchIndexPatterns) DeepCopyInto(out *OpenSearchIndexPatterns) {
	*out = *in
	if in.MaxIndexCount != nil {
		in, out := &in.MaxIndexCount, &out.MaxIndexCount
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchIndexPatterns.
func (in *OpenSearchIndexPatterns) DeepCopy() *OpenSearchIndexPatterns {
	if in == nil {
		return nil
	}
	out := new(OpenSearchIndexPatterns)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchIndexTemplate) DeepCopyInto(out *OpenSearchIndexTemplate) {
	*out = *in
	if in.NumberOfReplicas != nil {
		in, out := &in.NumberOfReplicas, &out.NumberOfReplicas
		*out = new(int64)
		**out = **in
	}
	if in.NumberOfShards != nil {
		in, out := &in.NumberOfShards, &out.NumberOfShards
		*out = new(int64)
		**out = **in
	}
	if in.MappingNestedObjectsLimit != nil {
		in, out := &in.MappingNestedObjectsLimit, &out.MappingNestedObjectsLimit
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchIndexTemplate.
func (in *OpenSearchIndexTemplate) DeepCopy() *OpenSearchIndexTemplate {
	if in == nil {
		return nil
	}
	out := new(OpenSearchIndexTemplate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchList) DeepCopyInto(out *OpenSearchList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]OpenSearch, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchList.
func (in *OpenSearchList) DeepCopy() *OpenSearchList {
	if in == nil {
		return nil
	}
	out := new(OpenSearchList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OpenSearchList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchPrivateAccess) DeepCopyInto(out *OpenSearchPrivateAccess) {
	*out = *in
	if in.Opensearch != nil {
		in, out := &in.Opensearch, &out.Opensearch
		*out = new(bool)
		**out = **in
	}
	if in.OpensearchDashboards != nil {
		in, out := &in.OpensearchDashboards, &out.OpensearchDashboards
		*out = new(bool)
		**out = **in
	}
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchPrivateAccess.
func (in *OpenSearchPrivateAccess) DeepCopy() *OpenSearchPrivateAccess {
	if in == nil {
		return nil
	}
	out := new(OpenSearchPrivateAccess)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchPrivatelinkAccess) DeepCopyInto(out *OpenSearchPrivatelinkAccess) {
	*out = *in
	if in.Opensearch != nil {
		in, out := &in.Opensearch, &out.Opensearch
		*out = new(bool)
		**out = **in
	}
	if in.OpensearchDashboards != nil {
		in, out := &in.OpensearchDashboards, &out.OpensearchDashboards
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchPrivatelinkAccess.
func (in *OpenSearchPrivatelinkAccess) DeepCopy() *OpenSearchPrivatelinkAccess {
	if in == nil {
		return nil
	}
	out := new(OpenSearchPrivatelinkAccess)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchPublicAccess) DeepCopyInto(out *OpenSearchPublicAccess) {
	*out = *in
	if in.OpensearchDashboards != nil {
		in, out := &in.OpensearchDashboards, &out.OpensearchDashboards
		*out = new(bool)
		**out = **in
	}
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
	if in.Opensearch != nil {
		in, out := &in.Opensearch, &out.Opensearch
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchPublicAccess.
func (in *OpenSearchPublicAccess) DeepCopy() *OpenSearchPublicAccess {
	if in == nil {
		return nil
	}
	out := new(OpenSearchPublicAccess)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchSpec) DeepCopyInto(out *OpenSearchSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	in.UserConfig.DeepCopyInto(&out.UserConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchSpec.
func (in *OpenSearchSpec) DeepCopy() *OpenSearchSpec {
	if in == nil {
		return nil
	}
	out := new(OpenSearchSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchUserConfig) DeepCopyInto(out *OpenSearchUserConfig) {
	*out = *in
	in.OpensearchDashboards.DeepCopyInto(&out.OpensearchDashboards)
	in.PrivatelinkAccess.DeepCopyInto(&out.PrivatelinkAccess)
	if in.StaticIps != nil {
		in, out := &in.StaticIps, &out.StaticIps
		*out = new(bool)
		**out = **in
	}
	in.PublicAccess.DeepCopyInto(&out.PublicAccess)
	if in.IndexPatterns != nil {
		in, out := &in.IndexPatterns, &out.IndexPatterns
		*out = make([]OpenSearchIndexPatterns, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.IpFilter != nil {
		in, out := &in.IpFilter, &out.IpFilter
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	in.PrivateAccess.DeepCopyInto(&out.PrivateAccess)
	in.IndexTemplate.DeepCopyInto(&out.IndexTemplate)
	in.Opensearch.DeepCopyInto(&out.Opensearch)
	if in.MaxIndexCount != nil {
		in, out := &in.MaxIndexCount, &out.MaxIndexCount
		*out = new(int64)
		**out = **in
	}
	if in.DisableReplicationFactorAdjustment != nil {
		in, out := &in.DisableReplicationFactorAdjustment, &out.DisableReplicationFactorAdjustment
		*out = new(bool)
		**out = **in
	}
	if in.KeepIndexRefreshInterval != nil {
		in, out := &in.KeepIndexRefreshInterval, &out.KeepIndexRefreshInterval
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchUserConfig.
func (in *OpenSearchUserConfig) DeepCopy() *OpenSearchUserConfig {
	if in == nil {
		return nil
	}
	out := new(OpenSearchUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchUserConfigOpenSearch) DeepCopyInto(out *OpenSearchUserConfigOpenSearch) {
	*out = *in
	if in.ThreadPoolAnalyzeQueueSize != nil {
		in, out := &in.ThreadPoolAnalyzeQueueSize, &out.ThreadPoolAnalyzeQueueSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolAnalyzeSize != nil {
		in, out := &in.ThreadPoolAnalyzeSize, &out.ThreadPoolAnalyzeSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolForceMergeSize != nil {
		in, out := &in.ThreadPoolForceMergeSize, &out.ThreadPoolForceMergeSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolGetSize != nil {
		in, out := &in.ThreadPoolGetSize, &out.ThreadPoolGetSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolSearchThrottledQueueSize != nil {
		in, out := &in.ThreadPoolSearchThrottledQueueSize, &out.ThreadPoolSearchThrottledQueueSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolWriteQueueSize != nil {
		in, out := &in.ThreadPoolWriteQueueSize, &out.ThreadPoolWriteQueueSize
		*out = new(int64)
		**out = **in
	}
	if in.ReindexRemoteWhitelist != nil {
		in, out := &in.ReindexRemoteWhitelist, &out.ReindexRemoteWhitelist
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.IndicesFielddataCacheSize != nil {
		in, out := &in.IndicesFielddataCacheSize, &out.IndicesFielddataCacheSize
		*out = new(int64)
		**out = **in
	}
	if in.IndicesQueryBoolMaxClauseCount != nil {
		in, out := &in.IndicesQueryBoolMaxClauseCount, &out.IndicesQueryBoolMaxClauseCount
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolGetQueueSize != nil {
		in, out := &in.ThreadPoolGetQueueSize, &out.ThreadPoolGetQueueSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolIndexSize != nil {
		in, out := &in.ThreadPoolIndexSize, &out.ThreadPoolIndexSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolSearchQueueSize != nil {
		in, out := &in.ThreadPoolSearchQueueSize, &out.ThreadPoolSearchQueueSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolWriteSize != nil {
		in, out := &in.ThreadPoolWriteSize, &out.ThreadPoolWriteSize
		*out = new(int64)
		**out = **in
	}
	if in.HttpMaxHeaderSize != nil {
		in, out := &in.HttpMaxHeaderSize, &out.HttpMaxHeaderSize
		*out = new(int64)
		**out = **in
	}
	if in.IndicesMemoryIndexBufferSize != nil {
		in, out := &in.IndicesMemoryIndexBufferSize, &out.IndicesMemoryIndexBufferSize
		*out = new(int64)
		**out = **in
	}
	if in.IndicesQueriesCacheSize != nil {
		in, out := &in.IndicesQueriesCacheSize, &out.IndicesQueriesCacheSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolSearchSize != nil {
		in, out := &in.ThreadPoolSearchSize, &out.ThreadPoolSearchSize
		*out = new(int64)
		**out = **in
	}
	if in.ThreadPoolSearchThrottledSize != nil {
		in, out := &in.ThreadPoolSearchThrottledSize, &out.ThreadPoolSearchThrottledSize
		*out = new(int64)
		**out = **in
	}
	if in.HttpMaxInitialLineLength != nil {
		in, out := &in.HttpMaxInitialLineLength, &out.HttpMaxInitialLineLength
		*out = new(int64)
		**out = **in
	}
	if in.ActionDestructiveRequiresName != nil {
		in, out := &in.ActionDestructiveRequiresName, &out.ActionDestructiveRequiresName
		*out = new(bool)
		**out = **in
	}
	if in.ClusterMaxShardsPerNode != nil {
		in, out := &in.ClusterMaxShardsPerNode, &out.ClusterMaxShardsPerNode
		*out = new(int64)
		**out = **in
	}
	if in.HttpMaxContentLength != nil {
		in, out := &in.HttpMaxContentLength, &out.HttpMaxContentLength
		*out = new(int64)
		**out = **in
	}
	if in.SearchMaxBuckets != nil {
		in, out := &in.SearchMaxBuckets, &out.SearchMaxBuckets
		*out = new(int64)
		**out = **in
	}
	if in.ActionAutoCreateIndexEnabled != nil {
		in, out := &in.ActionAutoCreateIndexEnabled, &out.ActionAutoCreateIndexEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchUserConfigOpenSearch.
func (in *OpenSearchUserConfigOpenSearch) DeepCopy() *OpenSearchUserConfigOpenSearch {
	if in == nil {
		return nil
	}
	out := new(OpenSearchUserConfigOpenSearch)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpensearchDashboards) DeepCopyInto(out *OpensearchDashboards) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.MaxOldSpaceSize != nil {
		in, out := &in.MaxOldSpaceSize, &out.MaxOldSpaceSize
		*out = new(int64)
		**out = **in
	}
	if in.OpensearchRequestTimeout != nil {
		in, out := &in.OpensearchRequestTimeout, &out.OpensearchRequestTimeout
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpensearchDashboards.
func (in *OpensearchDashboards) DeepCopy() *OpensearchDashboards {
	if in == nil {
		return nil
	}
	out := new(OpensearchDashboards)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostgreSQL) DeepCopyInto(out *PostgreSQL) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostgreSQL.
func (in *PostgreSQL) DeepCopy() *PostgreSQL {
	if in == nil {
		return nil
	}
	out := new(PostgreSQL)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PostgreSQL) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostgreSQLList) DeepCopyInto(out *PostgreSQLList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]PostgreSQL, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostgreSQLList.
func (in *PostgreSQLList) DeepCopy() *PostgreSQLList {
	if in == nil {
		return nil
	}
	out := new(PostgreSQLList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PostgreSQLList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostgreSQLSpec) DeepCopyInto(out *PostgreSQLSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = new(pg.PgUserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostgreSQLSpec.
func (in *PostgreSQLSpec) DeepCopy() *PostgreSQLSpec {
	if in == nil {
		return nil
	}
	out := new(PostgreSQLSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Project) DeepCopyInto(out *Project) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Project.
func (in *Project) DeepCopy() *Project {
	if in == nil {
		return nil
	}
	out := new(Project)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Project) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectList) DeepCopyInto(out *ProjectList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Project, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectList.
func (in *ProjectList) DeepCopy() *ProjectList {
	if in == nil {
		return nil
	}
	out := new(ProjectList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectSpec) DeepCopyInto(out *ProjectSpec) {
	*out = *in
	if in.BillingEmails != nil {
		in, out := &in.BillingEmails, &out.BillingEmails
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.TechnicalEmails != nil {
		in, out := &in.TechnicalEmails, &out.TechnicalEmails
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectSpec.
func (in *ProjectSpec) DeepCopy() *ProjectSpec {
	if in == nil {
		return nil
	}
	out := new(ProjectSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectStatus) DeepCopyInto(out *ProjectStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectStatus.
func (in *ProjectStatus) DeepCopy() *ProjectStatus {
	if in == nil {
		return nil
	}
	out := new(ProjectStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPC) DeepCopyInto(out *ProjectVPC) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPC.
func (in *ProjectVPC) DeepCopy() *ProjectVPC {
	if in == nil {
		return nil
	}
	out := new(ProjectVPC)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectVPC) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPCList) DeepCopyInto(out *ProjectVPCList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ProjectVPC, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPCList.
func (in *ProjectVPCList) DeepCopy() *ProjectVPCList {
	if in == nil {
		return nil
	}
	out := new(ProjectVPCList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectVPCList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPCSpec) DeepCopyInto(out *ProjectVPCSpec) {
	*out = *in
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPCSpec.
func (in *ProjectVPCSpec) DeepCopy() *ProjectVPCSpec {
	if in == nil {
		return nil
	}
	out := new(ProjectVPCSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPCStatus) DeepCopyInto(out *ProjectVPCStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPCStatus.
func (in *ProjectVPCStatus) DeepCopy() *ProjectVPCStatus {
	if in == nil {
		return nil
	}
	out := new(ProjectVPCStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Redis) DeepCopyInto(out *Redis) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Redis.
func (in *Redis) DeepCopy() *Redis {
	if in == nil {
		return nil
	}
	out := new(Redis)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Redis) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisList) DeepCopyInto(out *RedisList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Redis, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisList.
func (in *RedisList) DeepCopy() *RedisList {
	if in == nil {
		return nil
	}
	out := new(RedisList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RedisList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisMigration) DeepCopyInto(out *RedisMigration) {
	*out = *in
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int64)
		**out = **in
	}
	if in.Ssl != nil {
		in, out := &in.Ssl, &out.Ssl
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisMigration.
func (in *RedisMigration) DeepCopy() *RedisMigration {
	if in == nil {
		return nil
	}
	out := new(RedisMigration)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisPrivateAccess) DeepCopyInto(out *RedisPrivateAccess) {
	*out = *in
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisPrivateAccess.
func (in *RedisPrivateAccess) DeepCopy() *RedisPrivateAccess {
	if in == nil {
		return nil
	}
	out := new(RedisPrivateAccess)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisPrivatelinkAccess) DeepCopyInto(out *RedisPrivatelinkAccess) {
	*out = *in
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisPrivatelinkAccess.
func (in *RedisPrivatelinkAccess) DeepCopy() *RedisPrivatelinkAccess {
	if in == nil {
		return nil
	}
	out := new(RedisPrivatelinkAccess)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisPublicAccess) DeepCopyInto(out *RedisPublicAccess) {
	*out = *in
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisPublicAccess.
func (in *RedisPublicAccess) DeepCopy() *RedisPublicAccess {
	if in == nil {
		return nil
	}
	out := new(RedisPublicAccess)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisSpec) DeepCopyInto(out *RedisSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	out.AuthSecretRef = in.AuthSecretRef
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	in.UserConfig.DeepCopyInto(&out.UserConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisSpec.
func (in *RedisSpec) DeepCopy() *RedisSpec {
	if in == nil {
		return nil
	}
	out := new(RedisSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisUserConfig) DeepCopyInto(out *RedisUserConfig) {
	*out = *in
	in.Migration.DeepCopyInto(&out.Migration)
	in.PublicAccess.DeepCopyInto(&out.PublicAccess)
	in.PrivateAccess.DeepCopyInto(&out.PrivateAccess)
	in.PrivatelinkAccess.DeepCopyInto(&out.PrivatelinkAccess)
	if in.IPFilter != nil {
		in, out := &in.IPFilter, &out.IPFilter
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.RedisLfuDecayTime != nil {
		in, out := &in.RedisLfuDecayTime, &out.RedisLfuDecayTime
		*out = new(int64)
		**out = **in
	}
	if in.RedisLfuLogFactor != nil {
		in, out := &in.RedisLfuLogFactor, &out.RedisLfuLogFactor
		*out = new(int64)
		**out = **in
	}
	if in.RedisPubsubClientOutputBufferLimit != nil {
		in, out := &in.RedisPubsubClientOutputBufferLimit, &out.RedisPubsubClientOutputBufferLimit
		*out = new(int64)
		**out = **in
	}
	if in.StaticIps != nil {
		in, out := &in.StaticIps, &out.StaticIps
		*out = new(bool)
		**out = **in
	}
	if in.RedisIoThreads != nil {
		in, out := &in.RedisIoThreads, &out.RedisIoThreads
		*out = new(int64)
		**out = **in
	}
	if in.RedisTimeout != nil {
		in, out := &in.RedisTimeout, &out.RedisTimeout
		*out = new(int64)
		**out = **in
	}
	if in.RedisNumberOfDatabases != nil {
		in, out := &in.RedisNumberOfDatabases, &out.RedisNumberOfDatabases
		*out = new(int64)
		**out = **in
	}
	if in.RedisSsl != nil {
		in, out := &in.RedisSsl, &out.RedisSsl
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisUserConfig.
func (in *RedisUserConfig) DeepCopy() *RedisUserConfig {
	if in == nil {
		return nil
	}
	out := new(RedisUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ResourceReference) DeepCopyInto(out *ResourceReference) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ResourceReference.
func (in *ResourceReference) DeepCopy() *ResourceReference {
	if in == nil {
		return nil
	}
	out := new(ResourceReference)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ResourceReferenceObject) DeepCopyInto(out *ResourceReferenceObject) {
	*out = *in
	out.GroupVersionKind = in.GroupVersionKind
	out.NamespacedName = in.NamespacedName
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ResourceReferenceObject.
func (in *ResourceReferenceObject) DeepCopy() *ResourceReferenceObject {
	if in == nil {
		return nil
	}
	out := new(ResourceReferenceObject)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceCommonSpec) DeepCopyInto(out *ServiceCommonSpec) {
	*out = *in
	if in.ProjectVPCRef != nil {
		in, out := &in.ProjectVPCRef, &out.ProjectVPCRef
		*out = new(ResourceReference)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ServiceIntegrations != nil {
		in, out := &in.ServiceIntegrations, &out.ServiceIntegrations
		*out = make([]*ServiceIntegrationItem, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(ServiceIntegrationItem)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceCommonSpec.
func (in *ServiceCommonSpec) DeepCopy() *ServiceCommonSpec {
	if in == nil {
		return nil
	}
	out := new(ServiceCommonSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegration) DeepCopyInto(out *ServiceIntegration) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegration.
func (in *ServiceIntegration) DeepCopy() *ServiceIntegration {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegration)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceIntegration) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationDatadogUserConfig) DeepCopyInto(out *ServiceIntegrationDatadogUserConfig) {
	*out = *in
	if in.ExcludeConsumerGroups != nil {
		in, out := &in.ExcludeConsumerGroups, &out.ExcludeConsumerGroups
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ExcludeTopics != nil {
		in, out := &in.ExcludeTopics, &out.ExcludeTopics
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.IncludeConsumerGroups != nil {
		in, out := &in.IncludeConsumerGroups, &out.IncludeConsumerGroups
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.IncludeTopics != nil {
		in, out := &in.IncludeTopics, &out.IncludeTopics
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.KafkaCustomMetrics != nil {
		in, out := &in.KafkaCustomMetrics, &out.KafkaCustomMetrics
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationDatadogUserConfig.
func (in *ServiceIntegrationDatadogUserConfig) DeepCopy() *ServiceIntegrationDatadogUserConfig {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationDatadogUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationItem) DeepCopyInto(out *ServiceIntegrationItem) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationItem.
func (in *ServiceIntegrationItem) DeepCopy() *ServiceIntegrationItem {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationItem)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationKafkaConnect) DeepCopyInto(out *ServiceIntegrationKafkaConnect) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationKafkaConnect.
func (in *ServiceIntegrationKafkaConnect) DeepCopy() *ServiceIntegrationKafkaConnect {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationKafkaConnect)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationKafkaConnectUserConfig) DeepCopyInto(out *ServiceIntegrationKafkaConnectUserConfig) {
	*out = *in
	out.KafkaConnect = in.KafkaConnect
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationKafkaConnectUserConfig.
func (in *ServiceIntegrationKafkaConnectUserConfig) DeepCopy() *ServiceIntegrationKafkaConnectUserConfig {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationKafkaConnectUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationKafkaLogsUserConfig) DeepCopyInto(out *ServiceIntegrationKafkaLogsUserConfig) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationKafkaLogsUserConfig.
func (in *ServiceIntegrationKafkaLogsUserConfig) DeepCopy() *ServiceIntegrationKafkaLogsUserConfig {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationKafkaLogsUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationList) DeepCopyInto(out *ServiceIntegrationList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ServiceIntegration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationList.
func (in *ServiceIntegrationList) DeepCopy() *ServiceIntegrationList {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceIntegrationList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationMetricsUserConfig) DeepCopyInto(out *ServiceIntegrationMetricsUserConfig) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationMetricsUserConfig.
func (in *ServiceIntegrationMetricsUserConfig) DeepCopy() *ServiceIntegrationMetricsUserConfig {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationMetricsUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationSpec) DeepCopyInto(out *ServiceIntegrationSpec) {
	*out = *in
	in.DatadogUserConfig.DeepCopyInto(&out.DatadogUserConfig)
	out.KafkaConnectUserConfig = in.KafkaConnectUserConfig
	out.KafkaLogsUserConfig = in.KafkaLogsUserConfig
	out.MetricsUserConfig = in.MetricsUserConfig
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationSpec.
func (in *ServiceIntegrationSpec) DeepCopy() *ServiceIntegrationSpec {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationStatus) DeepCopyInto(out *ServiceIntegrationStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationStatus.
func (in *ServiceIntegrationStatus) DeepCopy() *ServiceIntegrationStatus {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceStatus) DeepCopyInto(out *ServiceStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceStatus.
func (in *ServiceStatus) DeepCopy() *ServiceStatus {
	if in == nil {
		return nil
	}
	out := new(ServiceStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUser) DeepCopyInto(out *ServiceUser) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUser.
func (in *ServiceUser) DeepCopy() *ServiceUser {
	if in == nil {
		return nil
	}
	out := new(ServiceUser)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceUser) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUserList) DeepCopyInto(out *ServiceUserList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ServiceUser, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUserList.
func (in *ServiceUserList) DeepCopy() *ServiceUserList {
	if in == nil {
		return nil
	}
	out := new(ServiceUserList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceUserList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUserSpec) DeepCopyInto(out *ServiceUserSpec) {
	*out = *in
	out.ConnInfoSecretTarget = in.ConnInfoSecretTarget
	out.AuthSecretRef = in.AuthSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUserSpec.
func (in *ServiceUserSpec) DeepCopy() *ServiceUserSpec {
	if in == nil {
		return nil
	}
	out := new(ServiceUserSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUserStatus) DeepCopyInto(out *ServiceUserStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUserStatus.
func (in *ServiceUserStatus) DeepCopy() *ServiceUserStatus {
	if in == nil {
		return nil
	}
	out := new(ServiceUserStatus)
	in.DeepCopyInto(out)
	return out
}
