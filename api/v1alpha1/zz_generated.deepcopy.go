//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Copyright (c) 2024 Aiven, Helsinki, Finland. https://aiven.io/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"

	clickhouse_kafka "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/integration/clickhouse_kafka"
	clickhouse_postgresql "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/integration/clickhouse_postgresql"
	datadog "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/integration/datadog"
	external_aws_cloudwatch_metrics "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/integration/external_aws_cloudwatch_metrics"
	integrationkafka_connect "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/integration/kafka_connect"
	kafka_logs "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/integration/kafka_logs"
	kafka_mirrormaker "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/integration/kafka_mirrormaker"
	logs "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/integration/logs"
	metrics "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/integration/metrics"
	cassandra "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/service/cassandra"
	clickhouse "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/service/clickhouse"
	grafana "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/service/grafana"
	kafka "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/service/kafka"
	kafka_connect "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/service/kafka_connect"
	mysql "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/service/mysql"
	opensearch "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/service/opensearch"
	pg "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/service/pg"
	redis "github.com/aiven/aiven-operator/api/v1alpha1/userconfig/service/redis"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthSecretReference) DeepCopyInto(out *AuthSecretReference) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthSecretReference.
func (in *AuthSecretReference) DeepCopy() *AuthSecretReference {
	if in == nil {
		return nil
	}
	out := new(AuthSecretReference)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Cassandra) DeepCopyInto(out *Cassandra) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Cassandra.
func (in *Cassandra) DeepCopy() *Cassandra {
	if in == nil {
		return nil
	}
	out := new(Cassandra)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Cassandra) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CassandraList) DeepCopyInto(out *CassandraList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Cassandra, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CassandraList.
func (in *CassandraList) DeepCopy() *CassandraList {
	if in == nil {
		return nil
	}
	out := new(CassandraList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CassandraList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CassandraSpec) DeepCopyInto(out *CassandraSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
	in.ConnInfoSecretTarget.DeepCopyInto(&out.ConnInfoSecretTarget)
	if in.ConnInfoSecretTargetDisabled != nil {
		in, out := &in.ConnInfoSecretTargetDisabled, &out.ConnInfoSecretTargetDisabled
		*out = new(bool)
		**out = **in
	}
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = new(cassandra.CassandraUserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CassandraSpec.
func (in *CassandraSpec) DeepCopy() *CassandraSpec {
	if in == nil {
		return nil
	}
	out := new(CassandraSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Clickhouse) DeepCopyInto(out *Clickhouse) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Clickhouse.
func (in *Clickhouse) DeepCopy() *Clickhouse {
	if in == nil {
		return nil
	}
	out := new(Clickhouse)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Clickhouse) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseDatabase) DeepCopyInto(out *ClickhouseDatabase) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseDatabase.
func (in *ClickhouseDatabase) DeepCopy() *ClickhouseDatabase {
	if in == nil {
		return nil
	}
	out := new(ClickhouseDatabase)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClickhouseDatabase) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseDatabaseList) DeepCopyInto(out *ClickhouseDatabaseList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClickhouseDatabase, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseDatabaseList.
func (in *ClickhouseDatabaseList) DeepCopy() *ClickhouseDatabaseList {
	if in == nil {
		return nil
	}
	out := new(ClickhouseDatabaseList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClickhouseDatabaseList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseDatabaseSpec) DeepCopyInto(out *ClickhouseDatabaseSpec) {
	*out = *in
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseDatabaseSpec.
func (in *ClickhouseDatabaseSpec) DeepCopy() *ClickhouseDatabaseSpec {
	if in == nil {
		return nil
	}
	out := new(ClickhouseDatabaseSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseDatabaseStatus) DeepCopyInto(out *ClickhouseDatabaseStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseDatabaseStatus.
func (in *ClickhouseDatabaseStatus) DeepCopy() *ClickhouseDatabaseStatus {
	if in == nil {
		return nil
	}
	out := new(ClickhouseDatabaseStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseList) DeepCopyInto(out *ClickhouseList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Clickhouse, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseList.
func (in *ClickhouseList) DeepCopy() *ClickhouseList {
	if in == nil {
		return nil
	}
	out := new(ClickhouseList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClickhouseList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseSpec) DeepCopyInto(out *ClickhouseSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
	in.ConnInfoSecretTarget.DeepCopyInto(&out.ConnInfoSecretTarget)
	if in.ConnInfoSecretTargetDisabled != nil {
		in, out := &in.ConnInfoSecretTargetDisabled, &out.ConnInfoSecretTargetDisabled
		*out = new(bool)
		**out = **in
	}
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = new(clickhouse.ClickhouseUserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseSpec.
func (in *ClickhouseSpec) DeepCopy() *ClickhouseSpec {
	if in == nil {
		return nil
	}
	out := new(ClickhouseSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseUser) DeepCopyInto(out *ClickhouseUser) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseUser.
func (in *ClickhouseUser) DeepCopy() *ClickhouseUser {
	if in == nil {
		return nil
	}
	out := new(ClickhouseUser)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClickhouseUser) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseUserList) DeepCopyInto(out *ClickhouseUserList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClickhouseUser, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseUserList.
func (in *ClickhouseUserList) DeepCopy() *ClickhouseUserList {
	if in == nil {
		return nil
	}
	out := new(ClickhouseUserList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClickhouseUserList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseUserSpec) DeepCopyInto(out *ClickhouseUserSpec) {
	*out = *in
	in.ConnInfoSecretTarget.DeepCopyInto(&out.ConnInfoSecretTarget)
	if in.ConnInfoSecretTargetDisabled != nil {
		in, out := &in.ConnInfoSecretTargetDisabled, &out.ConnInfoSecretTargetDisabled
		*out = new(bool)
		**out = **in
	}
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseUserSpec.
func (in *ClickhouseUserSpec) DeepCopy() *ClickhouseUserSpec {
	if in == nil {
		return nil
	}
	out := new(ClickhouseUserSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClickhouseUserStatus) DeepCopyInto(out *ClickhouseUserStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClickhouseUserStatus.
func (in *ClickhouseUserStatus) DeepCopy() *ClickhouseUserStatus {
	if in == nil {
		return nil
	}
	out := new(ClickhouseUserStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnInfoSecretTarget) DeepCopyInto(out *ConnInfoSecretTarget) {
	*out = *in
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnInfoSecretTarget.
func (in *ConnInfoSecretTarget) DeepCopy() *ConnInfoSecretTarget {
	if in == nil {
		return nil
	}
	out := new(ConnInfoSecretTarget)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPool) DeepCopyInto(out *ConnectionPool) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPool.
func (in *ConnectionPool) DeepCopy() *ConnectionPool {
	if in == nil {
		return nil
	}
	out := new(ConnectionPool)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ConnectionPool) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPoolList) DeepCopyInto(out *ConnectionPoolList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ConnectionPool, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPoolList.
func (in *ConnectionPoolList) DeepCopy() *ConnectionPoolList {
	if in == nil {
		return nil
	}
	out := new(ConnectionPoolList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ConnectionPoolList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPoolSpec) DeepCopyInto(out *ConnectionPoolSpec) {
	*out = *in
	in.ConnInfoSecretTarget.DeepCopyInto(&out.ConnInfoSecretTarget)
	if in.ConnInfoSecretTargetDisabled != nil {
		in, out := &in.ConnInfoSecretTargetDisabled, &out.ConnInfoSecretTargetDisabled
		*out = new(bool)
		**out = **in
	}
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPoolSpec.
func (in *ConnectionPoolSpec) DeepCopy() *ConnectionPoolSpec {
	if in == nil {
		return nil
	}
	out := new(ConnectionPoolSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPoolStatus) DeepCopyInto(out *ConnectionPoolStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPoolStatus.
func (in *ConnectionPoolStatus) DeepCopy() *ConnectionPoolStatus {
	if in == nil {
		return nil
	}
	out := new(ConnectionPoolStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Database) DeepCopyInto(out *Database) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Database.
func (in *Database) DeepCopy() *Database {
	if in == nil {
		return nil
	}
	out := new(Database)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Database) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseList) DeepCopyInto(out *DatabaseList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Database, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseList.
func (in *DatabaseList) DeepCopy() *DatabaseList {
	if in == nil {
		return nil
	}
	out := new(DatabaseList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DatabaseList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseSpec) DeepCopyInto(out *DatabaseSpec) {
	*out = *in
	if in.TerminationProtection != nil {
		in, out := &in.TerminationProtection, &out.TerminationProtection
		*out = new(bool)
		**out = **in
	}
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseSpec.
func (in *DatabaseSpec) DeepCopy() *DatabaseSpec {
	if in == nil {
		return nil
	}
	out := new(DatabaseSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseStatus) DeepCopyInto(out *DatabaseStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseStatus.
func (in *DatabaseStatus) DeepCopy() *DatabaseStatus {
	if in == nil {
		return nil
	}
	out := new(DatabaseStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Grafana) DeepCopyInto(out *Grafana) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Grafana.
func (in *Grafana) DeepCopy() *Grafana {
	if in == nil {
		return nil
	}
	out := new(Grafana)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Grafana) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GrafanaList) DeepCopyInto(out *GrafanaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Grafana, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GrafanaList.
func (in *GrafanaList) DeepCopy() *GrafanaList {
	if in == nil {
		return nil
	}
	out := new(GrafanaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GrafanaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GrafanaSpec) DeepCopyInto(out *GrafanaSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
	in.ConnInfoSecretTarget.DeepCopyInto(&out.ConnInfoSecretTarget)
	if in.ConnInfoSecretTargetDisabled != nil {
		in, out := &in.ConnInfoSecretTargetDisabled, &out.ConnInfoSecretTargetDisabled
		*out = new(bool)
		**out = **in
	}
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = new(grafana.GrafanaUserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GrafanaSpec.
func (in *GrafanaSpec) DeepCopy() *GrafanaSpec {
	if in == nil {
		return nil
	}
	out := new(GrafanaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Kafka) DeepCopyInto(out *Kafka) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Kafka.
func (in *Kafka) DeepCopy() *Kafka {
	if in == nil {
		return nil
	}
	out := new(Kafka)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Kafka) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaACL) DeepCopyInto(out *KafkaACL) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaACL.
func (in *KafkaACL) DeepCopy() *KafkaACL {
	if in == nil {
		return nil
	}
	out := new(KafkaACL)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaACL) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaACLList) DeepCopyInto(out *KafkaACLList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaACL, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaACLList.
func (in *KafkaACLList) DeepCopy() *KafkaACLList {
	if in == nil {
		return nil
	}
	out := new(KafkaACLList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaACLList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaACLSpec) DeepCopyInto(out *KafkaACLSpec) {
	*out = *in
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaACLSpec.
func (in *KafkaACLSpec) DeepCopy() *KafkaACLSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaACLSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaACLStatus) DeepCopyInto(out *KafkaACLStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaACLStatus.
func (in *KafkaACLStatus) DeepCopy() *KafkaACLStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaACLStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnect) DeepCopyInto(out *KafkaConnect) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnect.
func (in *KafkaConnect) DeepCopy() *KafkaConnect {
	if in == nil {
		return nil
	}
	out := new(KafkaConnect)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConnect) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectList) DeepCopyInto(out *KafkaConnectList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaConnect, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectList.
func (in *KafkaConnectList) DeepCopy() *KafkaConnectList {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConnectList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectSpec) DeepCopyInto(out *KafkaConnectSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = new(kafka_connect.KafkaConnectUserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectSpec.
func (in *KafkaConnectSpec) DeepCopy() *KafkaConnectSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnector) DeepCopyInto(out *KafkaConnector) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnector.
func (in *KafkaConnector) DeepCopy() *KafkaConnector {
	if in == nil {
		return nil
	}
	out := new(KafkaConnector)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConnector) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorList) DeepCopyInto(out *KafkaConnectorList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaConnector, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorList.
func (in *KafkaConnectorList) DeepCopy() *KafkaConnectorList {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConnectorList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorPluginStatus) DeepCopyInto(out *KafkaConnectorPluginStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorPluginStatus.
func (in *KafkaConnectorPluginStatus) DeepCopy() *KafkaConnectorPluginStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorPluginStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorSpec) DeepCopyInto(out *KafkaConnectorSpec) {
	*out = *in
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorSpec.
func (in *KafkaConnectorSpec) DeepCopy() *KafkaConnectorSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorStatus) DeepCopyInto(out *KafkaConnectorStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	out.PluginStatus = in.PluginStatus
	out.TasksStatus = in.TasksStatus
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorStatus.
func (in *KafkaConnectorStatus) DeepCopy() *KafkaConnectorStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectorTasksStatus) DeepCopyInto(out *KafkaConnectorTasksStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectorTasksStatus.
func (in *KafkaConnectorTasksStatus) DeepCopy() *KafkaConnectorTasksStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectorTasksStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaList) DeepCopyInto(out *KafkaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Kafka, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaList.
func (in *KafkaList) DeepCopy() *KafkaList {
	if in == nil {
		return nil
	}
	out := new(KafkaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSchema) DeepCopyInto(out *KafkaSchema) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSchema.
func (in *KafkaSchema) DeepCopy() *KafkaSchema {
	if in == nil {
		return nil
	}
	out := new(KafkaSchema)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaSchema) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSchemaList) DeepCopyInto(out *KafkaSchemaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaSchema, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSchemaList.
func (in *KafkaSchemaList) DeepCopy() *KafkaSchemaList {
	if in == nil {
		return nil
	}
	out := new(KafkaSchemaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaSchemaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSchemaSpec) DeepCopyInto(out *KafkaSchemaSpec) {
	*out = *in
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSchemaSpec.
func (in *KafkaSchemaSpec) DeepCopy() *KafkaSchemaSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaSchemaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSchemaStatus) DeepCopyInto(out *KafkaSchemaStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSchemaStatus.
func (in *KafkaSchemaStatus) DeepCopy() *KafkaSchemaStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaSchemaStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSpec) DeepCopyInto(out *KafkaSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
	in.ConnInfoSecretTarget.DeepCopyInto(&out.ConnInfoSecretTarget)
	if in.ConnInfoSecretTargetDisabled != nil {
		in, out := &in.ConnInfoSecretTargetDisabled, &out.ConnInfoSecretTargetDisabled
		*out = new(bool)
		**out = **in
	}
	if in.Karapace != nil {
		in, out := &in.Karapace, &out.Karapace
		*out = new(bool)
		**out = **in
	}
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = new(kafka.KafkaUserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSpec.
func (in *KafkaSpec) DeepCopy() *KafkaSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopic) DeepCopyInto(out *KafkaTopic) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopic.
func (in *KafkaTopic) DeepCopy() *KafkaTopic {
	if in == nil {
		return nil
	}
	out := new(KafkaTopic)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaTopic) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicConfig) DeepCopyInto(out *KafkaTopicConfig) {
	*out = *in
	if in.DeleteRetentionMs != nil {
		in, out := &in.DeleteRetentionMs, &out.DeleteRetentionMs
		*out = new(int64)
		**out = **in
	}
	if in.FileDeleteDelayMs != nil {
		in, out := &in.FileDeleteDelayMs, &out.FileDeleteDelayMs
		*out = new(int64)
		**out = **in
	}
	if in.FlushMessages != nil {
		in, out := &in.FlushMessages, &out.FlushMessages
		*out = new(int64)
		**out = **in
	}
	if in.FlushMs != nil {
		in, out := &in.FlushMs, &out.FlushMs
		*out = new(int64)
		**out = **in
	}
	if in.IndexIntervalBytes != nil {
		in, out := &in.IndexIntervalBytes, &out.IndexIntervalBytes
		*out = new(int64)
		**out = **in
	}
	if in.LocalRetentionBytes != nil {
		in, out := &in.LocalRetentionBytes, &out.LocalRetentionBytes
		*out = new(int64)
		**out = **in
	}
	if in.LocalRetentionMs != nil {
		in, out := &in.LocalRetentionMs, &out.LocalRetentionMs
		*out = new(int64)
		**out = **in
	}
	if in.MaxCompactionLagMs != nil {
		in, out := &in.MaxCompactionLagMs, &out.MaxCompactionLagMs
		*out = new(int64)
		**out = **in
	}
	if in.MaxMessageBytes != nil {
		in, out := &in.MaxMessageBytes, &out.MaxMessageBytes
		*out = new(int64)
		**out = **in
	}
	if in.MessageDownconversionEnable != nil {
		in, out := &in.MessageDownconversionEnable, &out.MessageDownconversionEnable
		*out = new(bool)
		**out = **in
	}
	if in.MessageTimestampDifferenceMaxMs != nil {
		in, out := &in.MessageTimestampDifferenceMaxMs, &out.MessageTimestampDifferenceMaxMs
		*out = new(int64)
		**out = **in
	}
	if in.MinCleanableDirtyRatio != nil {
		in, out := &in.MinCleanableDirtyRatio, &out.MinCleanableDirtyRatio
		*out = new(float64)
		**out = **in
	}
	if in.MinCompactionLagMs != nil {
		in, out := &in.MinCompactionLagMs, &out.MinCompactionLagMs
		*out = new(int64)
		**out = **in
	}
	if in.MinInsyncReplicas != nil {
		in, out := &in.MinInsyncReplicas, &out.MinInsyncReplicas
		*out = new(int64)
		**out = **in
	}
	if in.Preallocate != nil {
		in, out := &in.Preallocate, &out.Preallocate
		*out = new(bool)
		**out = **in
	}
	if in.RemoteStorageEnable != nil {
		in, out := &in.RemoteStorageEnable, &out.RemoteStorageEnable
		*out = new(bool)
		**out = **in
	}
	if in.RetentionBytes != nil {
		in, out := &in.RetentionBytes, &out.RetentionBytes
		*out = new(int64)
		**out = **in
	}
	if in.RetentionMs != nil {
		in, out := &in.RetentionMs, &out.RetentionMs
		*out = new(int64)
		**out = **in
	}
	if in.SegmentBytes != nil {
		in, out := &in.SegmentBytes, &out.SegmentBytes
		*out = new(int64)
		**out = **in
	}
	if in.SegmentIndexBytes != nil {
		in, out := &in.SegmentIndexBytes, &out.SegmentIndexBytes
		*out = new(int64)
		**out = **in
	}
	if in.SegmentJitterMs != nil {
		in, out := &in.SegmentJitterMs, &out.SegmentJitterMs
		*out = new(int64)
		**out = **in
	}
	if in.SegmentMs != nil {
		in, out := &in.SegmentMs, &out.SegmentMs
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicConfig.
func (in *KafkaTopicConfig) DeepCopy() *KafkaTopicConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicList) DeepCopyInto(out *KafkaTopicList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaTopic, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicList.
func (in *KafkaTopicList) DeepCopy() *KafkaTopicList {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaTopicList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicSpec) DeepCopyInto(out *KafkaTopicSpec) {
	*out = *in
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make([]KafkaTopicTag, len(*in))
		copy(*out, *in)
	}
	in.Config.DeepCopyInto(&out.Config)
	if in.TerminationProtection != nil {
		in, out := &in.TerminationProtection, &out.TerminationProtection
		*out = new(bool)
		**out = **in
	}
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicSpec.
func (in *KafkaTopicSpec) DeepCopy() *KafkaTopicSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicStatus) DeepCopyInto(out *KafkaTopicStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicStatus.
func (in *KafkaTopicStatus) DeepCopy() *KafkaTopicStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicTag) DeepCopyInto(out *KafkaTopicTag) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicTag.
func (in *KafkaTopicTag) DeepCopy() *KafkaTopicTag {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicTag)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQL) DeepCopyInto(out *MySQL) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQL.
func (in *MySQL) DeepCopy() *MySQL {
	if in == nil {
		return nil
	}
	out := new(MySQL)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *MySQL) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLList) DeepCopyInto(out *MySQLList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]MySQL, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLList.
func (in *MySQLList) DeepCopy() *MySQLList {
	if in == nil {
		return nil
	}
	out := new(MySQLList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *MySQLList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLSpec) DeepCopyInto(out *MySQLSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
	in.ConnInfoSecretTarget.DeepCopyInto(&out.ConnInfoSecretTarget)
	if in.ConnInfoSecretTargetDisabled != nil {
		in, out := &in.ConnInfoSecretTargetDisabled, &out.ConnInfoSecretTargetDisabled
		*out = new(bool)
		**out = **in
	}
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = new(mysql.MysqlUserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLSpec.
func (in *MySQLSpec) DeepCopy() *MySQLSpec {
	if in == nil {
		return nil
	}
	out := new(MySQLSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearch) DeepCopyInto(out *OpenSearch) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearch.
func (in *OpenSearch) DeepCopy() *OpenSearch {
	if in == nil {
		return nil
	}
	out := new(OpenSearch)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OpenSearch) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchList) DeepCopyInto(out *OpenSearchList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]OpenSearch, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchList.
func (in *OpenSearchList) DeepCopy() *OpenSearchList {
	if in == nil {
		return nil
	}
	out := new(OpenSearchList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OpenSearchList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearchSpec) DeepCopyInto(out *OpenSearchSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
	in.ConnInfoSecretTarget.DeepCopyInto(&out.ConnInfoSecretTarget)
	if in.ConnInfoSecretTargetDisabled != nil {
		in, out := &in.ConnInfoSecretTargetDisabled, &out.ConnInfoSecretTargetDisabled
		*out = new(bool)
		**out = **in
	}
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = new(opensearch.OpensearchUserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearchSpec.
func (in *OpenSearchSpec) DeepCopy() *OpenSearchSpec {
	if in == nil {
		return nil
	}
	out := new(OpenSearchSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostgreSQL) DeepCopyInto(out *PostgreSQL) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostgreSQL.
func (in *PostgreSQL) DeepCopy() *PostgreSQL {
	if in == nil {
		return nil
	}
	out := new(PostgreSQL)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PostgreSQL) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostgreSQLList) DeepCopyInto(out *PostgreSQLList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]PostgreSQL, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostgreSQLList.
func (in *PostgreSQLList) DeepCopy() *PostgreSQLList {
	if in == nil {
		return nil
	}
	out := new(PostgreSQLList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PostgreSQLList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PostgreSQLSpec) DeepCopyInto(out *PostgreSQLSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
	in.ConnInfoSecretTarget.DeepCopyInto(&out.ConnInfoSecretTarget)
	if in.ConnInfoSecretTargetDisabled != nil {
		in, out := &in.ConnInfoSecretTargetDisabled, &out.ConnInfoSecretTargetDisabled
		*out = new(bool)
		**out = **in
	}
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = new(pg.PgUserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PostgreSQLSpec.
func (in *PostgreSQLSpec) DeepCopy() *PostgreSQLSpec {
	if in == nil {
		return nil
	}
	out := new(PostgreSQLSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Project) DeepCopyInto(out *Project) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Project.
func (in *Project) DeepCopy() *Project {
	if in == nil {
		return nil
	}
	out := new(Project)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Project) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectList) DeepCopyInto(out *ProjectList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Project, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectList.
func (in *ProjectList) DeepCopy() *ProjectList {
	if in == nil {
		return nil
	}
	out := new(ProjectList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectSpec) DeepCopyInto(out *ProjectSpec) {
	*out = *in
	if in.BillingEmails != nil {
		in, out := &in.BillingEmails, &out.BillingEmails
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.TechnicalEmails != nil {
		in, out := &in.TechnicalEmails, &out.TechnicalEmails
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	in.ConnInfoSecretTarget.DeepCopyInto(&out.ConnInfoSecretTarget)
	if in.ConnInfoSecretTargetDisabled != nil {
		in, out := &in.ConnInfoSecretTargetDisabled, &out.ConnInfoSecretTargetDisabled
		*out = new(bool)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectSpec.
func (in *ProjectSpec) DeepCopy() *ProjectSpec {
	if in == nil {
		return nil
	}
	out := new(ProjectSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectStatus) DeepCopyInto(out *ProjectStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectStatus.
func (in *ProjectStatus) DeepCopy() *ProjectStatus {
	if in == nil {
		return nil
	}
	out := new(ProjectStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPC) DeepCopyInto(out *ProjectVPC) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPC.
func (in *ProjectVPC) DeepCopy() *ProjectVPC {
	if in == nil {
		return nil
	}
	out := new(ProjectVPC)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectVPC) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPCList) DeepCopyInto(out *ProjectVPCList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ProjectVPC, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPCList.
func (in *ProjectVPCList) DeepCopy() *ProjectVPCList {
	if in == nil {
		return nil
	}
	out := new(ProjectVPCList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectVPCList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPCSpec) DeepCopyInto(out *ProjectVPCSpec) {
	*out = *in
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPCSpec.
func (in *ProjectVPCSpec) DeepCopy() *ProjectVPCSpec {
	if in == nil {
		return nil
	}
	out := new(ProjectVPCSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPCStatus) DeepCopyInto(out *ProjectVPCStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPCStatus.
func (in *ProjectVPCStatus) DeepCopy() *ProjectVPCStatus {
	if in == nil {
		return nil
	}
	out := new(ProjectVPCStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Redis) DeepCopyInto(out *Redis) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Redis.
func (in *Redis) DeepCopy() *Redis {
	if in == nil {
		return nil
	}
	out := new(Redis)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Redis) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisList) DeepCopyInto(out *RedisList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Redis, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisList.
func (in *RedisList) DeepCopy() *RedisList {
	if in == nil {
		return nil
	}
	out := new(RedisList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RedisList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisSpec) DeepCopyInto(out *RedisSpec) {
	*out = *in
	in.ServiceCommonSpec.DeepCopyInto(&out.ServiceCommonSpec)
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
	in.ConnInfoSecretTarget.DeepCopyInto(&out.ConnInfoSecretTarget)
	if in.ConnInfoSecretTargetDisabled != nil {
		in, out := &in.ConnInfoSecretTargetDisabled, &out.ConnInfoSecretTargetDisabled
		*out = new(bool)
		**out = **in
	}
	if in.UserConfig != nil {
		in, out := &in.UserConfig, &out.UserConfig
		*out = new(redis.RedisUserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisSpec.
func (in *RedisSpec) DeepCopy() *RedisSpec {
	if in == nil {
		return nil
	}
	out := new(RedisSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ResourceReference) DeepCopyInto(out *ResourceReference) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ResourceReference.
func (in *ResourceReference) DeepCopy() *ResourceReference {
	if in == nil {
		return nil
	}
	out := new(ResourceReference)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ResourceReferenceObject) DeepCopyInto(out *ResourceReferenceObject) {
	*out = *in
	out.GroupVersionKind = in.GroupVersionKind
	out.NamespacedName = in.NamespacedName
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ResourceReferenceObject.
func (in *ResourceReferenceObject) DeepCopy() *ResourceReferenceObject {
	if in == nil {
		return nil
	}
	out := new(ResourceReferenceObject)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceCommonSpec) DeepCopyInto(out *ServiceCommonSpec) {
	*out = *in
	if in.ProjectVPCRef != nil {
		in, out := &in.ProjectVPCRef, &out.ProjectVPCRef
		*out = new(ResourceReference)
		**out = **in
	}
	if in.TerminationProtection != nil {
		in, out := &in.TerminationProtection, &out.TerminationProtection
		*out = new(bool)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ServiceIntegrations != nil {
		in, out := &in.ServiceIntegrations, &out.ServiceIntegrations
		*out = make([]*ServiceIntegrationItem, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(ServiceIntegrationItem)
				**out = **in
			}
		}
	}
	if in.TechnicalEmails != nil {
		in, out := &in.TechnicalEmails, &out.TechnicalEmails
		*out = make([]ServiceTechEmail, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceCommonSpec.
func (in *ServiceCommonSpec) DeepCopy() *ServiceCommonSpec {
	if in == nil {
		return nil
	}
	out := new(ServiceCommonSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegration) DeepCopyInto(out *ServiceIntegration) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegration.
func (in *ServiceIntegration) DeepCopy() *ServiceIntegration {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegration)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceIntegration) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationItem) DeepCopyInto(out *ServiceIntegrationItem) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationItem.
func (in *ServiceIntegrationItem) DeepCopy() *ServiceIntegrationItem {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationItem)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationList) DeepCopyInto(out *ServiceIntegrationList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ServiceIntegration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationList.
func (in *ServiceIntegrationList) DeepCopy() *ServiceIntegrationList {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceIntegrationList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationSpec) DeepCopyInto(out *ServiceIntegrationSpec) {
	*out = *in
	if in.DatadogUserConfig != nil {
		in, out := &in.DatadogUserConfig, &out.DatadogUserConfig
		*out = new(datadog.DatadogUserConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.KafkaConnectUserConfig != nil {
		in, out := &in.KafkaConnectUserConfig, &out.KafkaConnectUserConfig
		*out = new(integrationkafka_connect.KafkaConnectUserConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.KafkaLogsUserConfig != nil {
		in, out := &in.KafkaLogsUserConfig, &out.KafkaLogsUserConfig
		*out = new(kafka_logs.KafkaLogsUserConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.MetricsUserConfig != nil {
		in, out := &in.MetricsUserConfig, &out.MetricsUserConfig
		*out = new(metrics.MetricsUserConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.ClickhousePostgreSQLUserConfig != nil {
		in, out := &in.ClickhousePostgreSQLUserConfig, &out.ClickhousePostgreSQLUserConfig
		*out = new(clickhouse_postgresql.ClickhousePostgresqlUserConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.ClickhouseKafkaUserConfig != nil {
		in, out := &in.ClickhouseKafkaUserConfig, &out.ClickhouseKafkaUserConfig
		*out = new(clickhouse_kafka.ClickhouseKafkaUserConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.KafkaMirrormakerUserConfig != nil {
		in, out := &in.KafkaMirrormakerUserConfig, &out.KafkaMirrormakerUserConfig
		*out = new(kafka_mirrormaker.KafkaMirrormakerUserConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.LogsUserConfig != nil {
		in, out := &in.LogsUserConfig, &out.LogsUserConfig
		*out = new(logs.LogsUserConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.ExternalAWSCloudwatchMetricsUserConfig != nil {
		in, out := &in.ExternalAWSCloudwatchMetricsUserConfig, &out.ExternalAWSCloudwatchMetricsUserConfig
		*out = new(external_aws_cloudwatch_metrics.ExternalAwsCloudwatchMetricsUserConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationSpec.
func (in *ServiceIntegrationSpec) DeepCopy() *ServiceIntegrationSpec {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceIntegrationStatus) DeepCopyInto(out *ServiceIntegrationStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceIntegrationStatus.
func (in *ServiceIntegrationStatus) DeepCopy() *ServiceIntegrationStatus {
	if in == nil {
		return nil
	}
	out := new(ServiceIntegrationStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceStatus) DeepCopyInto(out *ServiceStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceStatus.
func (in *ServiceStatus) DeepCopy() *ServiceStatus {
	if in == nil {
		return nil
	}
	out := new(ServiceStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceTechEmail) DeepCopyInto(out *ServiceTechEmail) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceTechEmail.
func (in *ServiceTechEmail) DeepCopy() *ServiceTechEmail {
	if in == nil {
		return nil
	}
	out := new(ServiceTechEmail)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUser) DeepCopyInto(out *ServiceUser) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUser.
func (in *ServiceUser) DeepCopy() *ServiceUser {
	if in == nil {
		return nil
	}
	out := new(ServiceUser)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceUser) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUserList) DeepCopyInto(out *ServiceUserList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ServiceUser, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUserList.
func (in *ServiceUserList) DeepCopy() *ServiceUserList {
	if in == nil {
		return nil
	}
	out := new(ServiceUserList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceUserList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUserSpec) DeepCopyInto(out *ServiceUserSpec) {
	*out = *in
	in.ConnInfoSecretTarget.DeepCopyInto(&out.ConnInfoSecretTarget)
	if in.ConnInfoSecretTargetDisabled != nil {
		in, out := &in.ConnInfoSecretTargetDisabled, &out.ConnInfoSecretTargetDisabled
		*out = new(bool)
		**out = **in
	}
	if in.AuthSecretRef != nil {
		in, out := &in.AuthSecretRef, &out.AuthSecretRef
		*out = new(AuthSecretReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUserSpec.
func (in *ServiceUserSpec) DeepCopy() *ServiceUserSpec {
	if in == nil {
		return nil
	}
	out := new(ServiceUserSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUserStatus) DeepCopyInto(out *ServiceUserStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUserStatus.
func (in *ServiceUserStatus) DeepCopy() *ServiceUserStatus {
	if in == nil {
		return nil
	}
	out := new(ServiceUserStatus)
	in.DeepCopyInto(out)
	return out
}
