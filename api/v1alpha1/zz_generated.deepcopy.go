// +build !ignore_autogenerated

// Copyright (c) 2021 Aiven, Helsinki, Finland. https://aiven.io/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPool) DeepCopyInto(out *ConnectionPool) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPool.
func (in *ConnectionPool) DeepCopy() *ConnectionPool {
	if in == nil {
		return nil
	}
	out := new(ConnectionPool)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ConnectionPool) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPoolList) DeepCopyInto(out *ConnectionPoolList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ConnectionPool, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPoolList.
func (in *ConnectionPoolList) DeepCopy() *ConnectionPoolList {
	if in == nil {
		return nil
	}
	out := new(ConnectionPoolList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ConnectionPoolList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPoolSpec) DeepCopyInto(out *ConnectionPoolSpec) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPoolSpec.
func (in *ConnectionPoolSpec) DeepCopy() *ConnectionPoolSpec {
	if in == nil {
		return nil
	}
	out := new(ConnectionPoolSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnectionPoolStatus) DeepCopyInto(out *ConnectionPoolStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnectionPoolStatus.
func (in *ConnectionPoolStatus) DeepCopy() *ConnectionPoolStatus {
	if in == nil {
		return nil
	}
	out := new(ConnectionPoolStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Database) DeepCopyInto(out *Database) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Database.
func (in *Database) DeepCopy() *Database {
	if in == nil {
		return nil
	}
	out := new(Database)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Database) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseList) DeepCopyInto(out *DatabaseList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Database, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseList.
func (in *DatabaseList) DeepCopy() *DatabaseList {
	if in == nil {
		return nil
	}
	out := new(DatabaseList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DatabaseList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseSpec) DeepCopyInto(out *DatabaseSpec) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseSpec.
func (in *DatabaseSpec) DeepCopy() *DatabaseSpec {
	if in == nil {
		return nil
	}
	out := new(DatabaseSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseStatus) DeepCopyInto(out *DatabaseStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseStatus.
func (in *DatabaseStatus) DeepCopy() *DatabaseStatus {
	if in == nil {
		return nil
	}
	out := new(DatabaseStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Kafka) DeepCopyInto(out *Kafka) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Kafka.
func (in *Kafka) DeepCopy() *Kafka {
	if in == nil {
		return nil
	}
	out := new(Kafka)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Kafka) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaAuthenticationMethodsUserConfig) DeepCopyInto(out *KafkaAuthenticationMethodsUserConfig) {
	*out = *in
	if in.Certificate != nil {
		in, out := &in.Certificate, &out.Certificate
		*out = new(bool)
		**out = **in
	}
	if in.Sasl != nil {
		in, out := &in.Sasl, &out.Sasl
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaAuthenticationMethodsUserConfig.
func (in *KafkaAuthenticationMethodsUserConfig) DeepCopy() *KafkaAuthenticationMethodsUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaAuthenticationMethodsUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConnectUserConfig) DeepCopyInto(out *KafkaConnectUserConfig) {
	*out = *in
	if in.ConsumerMaxPollRecords != nil {
		in, out := &in.ConsumerMaxPollRecords, &out.ConsumerMaxPollRecords
		*out = new(int64)
		**out = **in
	}
	if in.OffsetFlushTimeoutMs != nil {
		in, out := &in.OffsetFlushTimeoutMs, &out.OffsetFlushTimeoutMs
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerFetchMaxBytes != nil {
		in, out := &in.ConsumerFetchMaxBytes, &out.ConsumerFetchMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerMaxPollIntervalMs != nil {
		in, out := &in.ConsumerMaxPollIntervalMs, &out.ConsumerMaxPollIntervalMs
		*out = new(int64)
		**out = **in
	}
	if in.OffsetFlushIntervalMs != nil {
		in, out := &in.OffsetFlushIntervalMs, &out.OffsetFlushIntervalMs
		*out = new(int64)
		**out = **in
	}
	if in.ProducerMaxRequestSize != nil {
		in, out := &in.ProducerMaxRequestSize, &out.ProducerMaxRequestSize
		*out = new(int64)
		**out = **in
	}
	if in.SessionTimeoutMs != nil {
		in, out := &in.SessionTimeoutMs, &out.SessionTimeoutMs
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerMaxPartitionFetchBytes != nil {
		in, out := &in.ConsumerMaxPartitionFetchBytes, &out.ConsumerMaxPartitionFetchBytes
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConnectUserConfig.
func (in *KafkaConnectUserConfig) DeepCopy() *KafkaConnectUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaConnectUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaList) DeepCopyInto(out *KafkaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Kafka, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaList.
func (in *KafkaList) DeepCopy() *KafkaList {
	if in == nil {
		return nil
	}
	out := new(KafkaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPrivateAccessUserConfig) DeepCopyInto(out *KafkaPrivateAccessUserConfig) {
	*out = *in
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPrivateAccessUserConfig.
func (in *KafkaPrivateAccessUserConfig) DeepCopy() *KafkaPrivateAccessUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaPrivateAccessUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPublicAccessUserConfig) DeepCopyInto(out *KafkaPublicAccessUserConfig) {
	*out = *in
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
	if in.SchemaRegistry != nil {
		in, out := &in.SchemaRegistry, &out.SchemaRegistry
		*out = new(bool)
		**out = **in
	}
	if in.Kafka != nil {
		in, out := &in.Kafka, &out.Kafka
		*out = new(bool)
		**out = **in
	}
	if in.KafkaConnect != nil {
		in, out := &in.KafkaConnect, &out.KafkaConnect
		*out = new(bool)
		**out = **in
	}
	if in.KafkaRest != nil {
		in, out := &in.KafkaRest, &out.KafkaRest
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPublicAccessUserConfig.
func (in *KafkaPublicAccessUserConfig) DeepCopy() *KafkaPublicAccessUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaPublicAccessUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaRestUserConfig) DeepCopyInto(out *KafkaRestUserConfig) {
	*out = *in
	if in.ConsumerRequestMaxBytes != nil {
		in, out := &in.ConsumerRequestMaxBytes, &out.ConsumerRequestMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerRequestTimeoutMs != nil {
		in, out := &in.ConsumerRequestTimeoutMs, &out.ConsumerRequestTimeoutMs
		*out = new(int64)
		**out = **in
	}
	if in.ProducerLingerMs != nil {
		in, out := &in.ProducerLingerMs, &out.ProducerLingerMs
		*out = new(int64)
		**out = **in
	}
	if in.SimpleconsumerPoolSizeMax != nil {
		in, out := &in.SimpleconsumerPoolSizeMax, &out.SimpleconsumerPoolSizeMax
		*out = new(int64)
		**out = **in
	}
	if in.ConsumerEnableAutoCommit != nil {
		in, out := &in.ConsumerEnableAutoCommit, &out.ConsumerEnableAutoCommit
		*out = new(bool)
		**out = **in
	}
	in.PublicAccess.DeepCopyInto(&out.PublicAccess)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaRestUserConfig.
func (in *KafkaRestUserConfig) DeepCopy() *KafkaRestUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaRestUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSchemaRegistryConfig) DeepCopyInto(out *KafkaSchemaRegistryConfig) {
	*out = *in
	if in.LeaderEligibility != nil {
		in, out := &in.LeaderEligibility, &out.LeaderEligibility
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSchemaRegistryConfig.
func (in *KafkaSchemaRegistryConfig) DeepCopy() *KafkaSchemaRegistryConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaSchemaRegistryConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSpec) DeepCopyInto(out *KafkaSpec) {
	*out = *in
	in.KafkaUserConfig.DeepCopyInto(&out.KafkaUserConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSpec.
func (in *KafkaSpec) DeepCopy() *KafkaSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaStatus) DeepCopyInto(out *KafkaStatus) {
	*out = *in
	in.KafkaUserConfig.DeepCopyInto(&out.KafkaUserConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaStatus.
func (in *KafkaStatus) DeepCopy() *KafkaStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSubKafkaUserConfig) DeepCopyInto(out *KafkaSubKafkaUserConfig) {
	*out = *in
	if in.MessageMaxBytes != nil {
		in, out := &in.MessageMaxBytes, &out.MessageMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.DefaultReplicationFactor != nil {
		in, out := &in.DefaultReplicationFactor, &out.DefaultReplicationFactor
		*out = new(int64)
		**out = **in
	}
	if in.LogCleanerMinCleanableRatio != nil {
		in, out := &in.LogCleanerMinCleanableRatio, &out.LogCleanerMinCleanableRatio
		*out = new(int64)
		**out = **in
	}
	if in.LogIndexIntervalBytes != nil {
		in, out := &in.LogIndexIntervalBytes, &out.LogIndexIntervalBytes
		*out = new(int64)
		**out = **in
	}
	if in.LogSegmentDeleteDelayMs != nil {
		in, out := &in.LogSegmentDeleteDelayMs, &out.LogSegmentDeleteDelayMs
		*out = new(int64)
		**out = **in
	}
	if in.MaxIncrementalFetchSessionCacheSlots != nil {
		in, out := &in.MaxIncrementalFetchSessionCacheSlots, &out.MaxIncrementalFetchSessionCacheSlots
		*out = new(int64)
		**out = **in
	}
	if in.SocketRequestMaxBytes != nil {
		in, out := &in.SocketRequestMaxBytes, &out.SocketRequestMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.LogCleanerDeleteRetentionMs != nil {
		in, out := &in.LogCleanerDeleteRetentionMs, &out.LogCleanerDeleteRetentionMs
		*out = new(int64)
		**out = **in
	}
	if in.LogIndexSizeMaxBytes != nil {
		in, out := &in.LogIndexSizeMaxBytes, &out.LogIndexSizeMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.LogRollJitterMs != nil {
		in, out := &in.LogRollJitterMs, &out.LogRollJitterMs
		*out = new(int64)
		**out = **in
	}
	if in.MaxConnectionsPerIP != nil {
		in, out := &in.MaxConnectionsPerIP, &out.MaxConnectionsPerIP
		*out = new(int64)
		**out = **in
	}
	if in.ReplicaFetchResponseMaxBytes != nil {
		in, out := &in.ReplicaFetchResponseMaxBytes, &out.ReplicaFetchResponseMaxBytes
		*out = new(int64)
		**out = **in
	}
	if in.AutoCreateTopicsEnable != nil {
		in, out := &in.AutoCreateTopicsEnable, &out.AutoCreateTopicsEnable
		*out = new(bool)
		**out = **in
	}
	if in.LogFlushIntervalMs != nil {
		in, out := &in.LogFlushIntervalMs, &out.LogFlushIntervalMs
		*out = new(int64)
		**out = **in
	}
	if in.LogMessageDownconversionEnable != nil {
		in, out := &in.LogMessageDownconversionEnable, &out.LogMessageDownconversionEnable
		*out = new(bool)
		**out = **in
	}
	if in.LogRollMs != nil {
		in, out := &in.LogRollMs, &out.LogRollMs
		*out = new(int64)
		**out = **in
	}
	if in.LogCleanerMinCompactionLagMs != nil {
		in, out := &in.LogCleanerMinCompactionLagMs, &out.LogCleanerMinCompactionLagMs
		*out = new(int64)
		**out = **in
	}
	if in.LogMessageTimestampDifferenceMaxMs != nil {
		in, out := &in.LogMessageTimestampDifferenceMaxMs, &out.LogMessageTimestampDifferenceMaxMs
		*out = new(int64)
		**out = **in
	}
	if in.LogRetentionMs != nil {
		in, out := &in.LogRetentionMs, &out.LogRetentionMs
		*out = new(int64)
		**out = **in
	}
	if in.GroupMinSessionTimeoutMs != nil {
		in, out := &in.GroupMinSessionTimeoutMs, &out.GroupMinSessionTimeoutMs
		*out = new(int64)
		**out = **in
	}
	if in.LogSegmentBytes != nil {
		in, out := &in.LogSegmentBytes, &out.LogSegmentBytes
		*out = new(int64)
		**out = **in
	}
	if in.GroupMaxSessionTimeoutMs != nil {
		in, out := &in.GroupMaxSessionTimeoutMs, &out.GroupMaxSessionTimeoutMs
		*out = new(int64)
		**out = **in
	}
	if in.LogFlushIntervalMessages != nil {
		in, out := &in.LogFlushIntervalMessages, &out.LogFlushIntervalMessages
		*out = new(int64)
		**out = **in
	}
	if in.LogPreallocate != nil {
		in, out := &in.LogPreallocate, &out.LogPreallocate
		*out = new(bool)
		**out = **in
	}
	if in.LogRetentionBytes != nil {
		in, out := &in.LogRetentionBytes, &out.LogRetentionBytes
		*out = new(int64)
		**out = **in
	}
	if in.LogCleanerMaxCompactionLagMs != nil {
		in, out := &in.LogCleanerMaxCompactionLagMs, &out.LogCleanerMaxCompactionLagMs
		*out = new(int64)
		**out = **in
	}
	if in.LogRetentionHours != nil {
		in, out := &in.LogRetentionHours, &out.LogRetentionHours
		*out = new(int64)
		**out = **in
	}
	if in.MinInsyncReplicas != nil {
		in, out := &in.MinInsyncReplicas, &out.MinInsyncReplicas
		*out = new(int64)
		**out = **in
	}
	if in.NumPartitions != nil {
		in, out := &in.NumPartitions, &out.NumPartitions
		*out = new(int64)
		**out = **in
	}
	if in.OffsetsRetentionMinutes != nil {
		in, out := &in.OffsetsRetentionMinutes, &out.OffsetsRetentionMinutes
		*out = new(int64)
		**out = **in
	}
	if in.ConnectionsMaxIdleMs != nil {
		in, out := &in.ConnectionsMaxIdleMs, &out.ConnectionsMaxIdleMs
		*out = new(int64)
		**out = **in
	}
	if in.ProducerPurgatoryPurgeIntervalRequests != nil {
		in, out := &in.ProducerPurgatoryPurgeIntervalRequests, &out.ProducerPurgatoryPurgeIntervalRequests
		*out = new(int64)
		**out = **in
	}
	if in.ReplicaFetchMaxBytes != nil {
		in, out := &in.ReplicaFetchMaxBytes, &out.ReplicaFetchMaxBytes
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSubKafkaUserConfig.
func (in *KafkaSubKafkaUserConfig) DeepCopy() *KafkaSubKafkaUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaSubKafkaUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserConfig) DeepCopyInto(out *KafkaUserConfig) {
	*out = *in
	if in.SchemaRegistry != nil {
		in, out := &in.SchemaRegistry, &out.SchemaRegistry
		*out = new(bool)
		**out = **in
	}
	in.Kafka.DeepCopyInto(&out.Kafka)
	in.KafkaConnectConfig.DeepCopyInto(&out.KafkaConnectConfig)
	in.PrivateAccess.DeepCopyInto(&out.PrivateAccess)
	in.SchemaRegistryConfig.DeepCopyInto(&out.SchemaRegistryConfig)
	if in.IPFilter != nil {
		in, out := &in.IPFilter, &out.IPFilter
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	in.KafkaAuthenticationMethods.DeepCopyInto(&out.KafkaAuthenticationMethods)
	if in.KafkaConnect != nil {
		in, out := &in.KafkaConnect, &out.KafkaConnect
		*out = new(bool)
		**out = **in
	}
	if in.KafkaRest != nil {
		in, out := &in.KafkaRest, &out.KafkaRest
		*out = new(bool)
		**out = **in
	}
	in.KafkaRestConfig.DeepCopyInto(&out.KafkaRestConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserConfig.
func (in *KafkaUserConfig) DeepCopy() *KafkaUserConfig {
	if in == nil {
		return nil
	}
	out := new(KafkaUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MigrationUserConfig) DeepCopyInto(out *MigrationUserConfig) {
	*out = *in
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int64)
		**out = **in
	}
	if in.Ssl != nil {
		in, out := &in.Ssl, &out.Ssl
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MigrationUserConfig.
func (in *MigrationUserConfig) DeepCopy() *MigrationUserConfig {
	if in == nil {
		return nil
	}
	out := new(MigrationUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PG) DeepCopyInto(out *PG) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PG.
func (in *PG) DeepCopy() *PG {
	if in == nil {
		return nil
	}
	out := new(PG)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PG) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PGList) DeepCopyInto(out *PGList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]PG, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PGList.
func (in *PGList) DeepCopy() *PGList {
	if in == nil {
		return nil
	}
	out := new(PGList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PGList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PGSpec) DeepCopyInto(out *PGSpec) {
	*out = *in
	in.PGUserConfig.DeepCopyInto(&out.PGUserConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PGSpec.
func (in *PGSpec) DeepCopy() *PGSpec {
	if in == nil {
		return nil
	}
	out := new(PGSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PGStatus) DeepCopyInto(out *PGStatus) {
	*out = *in
	in.PGUserConfig.DeepCopyInto(&out.PGUserConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PGStatus.
func (in *PGStatus) DeepCopy() *PGStatus {
	if in == nil {
		return nil
	}
	out := new(PGStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PGSubPGUserConfig) DeepCopyInto(out *PGSubPGUserConfig) {
	*out = *in
	if in.LogMinDurationStatement != nil {
		in, out := &in.LogMinDurationStatement, &out.LogMinDurationStatement
		*out = new(int64)
		**out = **in
	}
	if in.MaxReplicationSlots != nil {
		in, out := &in.MaxReplicationSlots, &out.MaxReplicationSlots
		*out = new(int64)
		**out = **in
	}
	if in.MaxStandbyStreamingDelay != nil {
		in, out := &in.MaxStandbyStreamingDelay, &out.MaxStandbyStreamingDelay
		*out = new(int64)
		**out = **in
	}
	if in.PgPartmanBgwInterval != nil {
		in, out := &in.PgPartmanBgwInterval, &out.PgPartmanBgwInterval
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumVacuumThreshold != nil {
		in, out := &in.AutovacuumVacuumThreshold, &out.AutovacuumVacuumThreshold
		*out = new(int64)
		**out = **in
	}
	if in.Jit != nil {
		in, out := &in.Jit, &out.Jit
		*out = new(bool)
		**out = **in
	}
	if in.MaxPreparedTransactions != nil {
		in, out := &in.MaxPreparedTransactions, &out.MaxPreparedTransactions
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumFreezeMaxAge != nil {
		in, out := &in.AutovacuumFreezeMaxAge, &out.AutovacuumFreezeMaxAge
		*out = new(int64)
		**out = **in
	}
	if in.IdleInTransactionSessionTimeout != nil {
		in, out := &in.IdleInTransactionSessionTimeout, &out.IdleInTransactionSessionTimeout
		*out = new(int64)
		**out = **in
	}
	if in.WalSenderTimeout != nil {
		in, out := &in.WalSenderTimeout, &out.WalSenderTimeout
		*out = new(int64)
		**out = **in
	}
	if in.MaxPredLocksPerTransaction != nil {
		in, out := &in.MaxPredLocksPerTransaction, &out.MaxPredLocksPerTransaction
		*out = new(int64)
		**out = **in
	}
	if in.MaxWalSenders != nil {
		in, out := &in.MaxWalSenders, &out.MaxWalSenders
		*out = new(int64)
		**out = **in
	}
	if in.TrackActivityQuerySize != nil {
		in, out := &in.TrackActivityQuerySize, &out.TrackActivityQuerySize
		*out = new(int64)
		**out = **in
	}
	if in.MaxFilesPerProcess != nil {
		in, out := &in.MaxFilesPerProcess, &out.MaxFilesPerProcess
		*out = new(int64)
		**out = **in
	}
	if in.MaxParallelWorkersPerGather != nil {
		in, out := &in.MaxParallelWorkersPerGather, &out.MaxParallelWorkersPerGather
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumVacuumScaleFactor != nil {
		in, out := &in.AutovacuumVacuumScaleFactor, &out.AutovacuumVacuumScaleFactor
		*out = new(int64)
		**out = **in
	}
	if in.LogAutovacuumMinDuration != nil {
		in, out := &in.LogAutovacuumMinDuration, &out.LogAutovacuumMinDuration
		*out = new(int64)
		**out = **in
	}
	if in.MaxLocksPerTransaction != nil {
		in, out := &in.MaxLocksPerTransaction, &out.MaxLocksPerTransaction
		*out = new(int64)
		**out = **in
	}
	if in.MaxStackDepth != nil {
		in, out := &in.MaxStackDepth, &out.MaxStackDepth
		*out = new(int64)
		**out = **in
	}
	if in.MaxWorkerProcesses != nil {
		in, out := &in.MaxWorkerProcesses, &out.MaxWorkerProcesses
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumAnalyzeScaleFactor != nil {
		in, out := &in.AutovacuumAnalyzeScaleFactor, &out.AutovacuumAnalyzeScaleFactor
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumVacuumCostLimit != nil {
		in, out := &in.AutovacuumVacuumCostLimit, &out.AutovacuumVacuumCostLimit
		*out = new(int64)
		**out = **in
	}
	if in.TempFileLimit != nil {
		in, out := &in.TempFileLimit, &out.TempFileLimit
		*out = new(int64)
		**out = **in
	}
	if in.MaxParallelWorkers != nil {
		in, out := &in.MaxParallelWorkers, &out.MaxParallelWorkers
		*out = new(int64)
		**out = **in
	}
	if in.MaxStandbyArchiveDelay != nil {
		in, out := &in.MaxStandbyArchiveDelay, &out.MaxStandbyArchiveDelay
		*out = new(int64)
		**out = **in
	}
	if in.WalWriterDelay != nil {
		in, out := &in.WalWriterDelay, &out.WalWriterDelay
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumAnalyzeThreshold != nil {
		in, out := &in.AutovacuumAnalyzeThreshold, &out.AutovacuumAnalyzeThreshold
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumNaptime != nil {
		in, out := &in.AutovacuumNaptime, &out.AutovacuumNaptime
		*out = new(int64)
		**out = **in
	}
	if in.DeadlockTimeout != nil {
		in, out := &in.DeadlockTimeout, &out.DeadlockTimeout
		*out = new(int64)
		**out = **in
	}
	if in.MaxLogicalReplicationWorkers != nil {
		in, out := &in.MaxLogicalReplicationWorkers, &out.MaxLogicalReplicationWorkers
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumMaxWorkers != nil {
		in, out := &in.AutovacuumMaxWorkers, &out.AutovacuumMaxWorkers
		*out = new(int64)
		**out = **in
	}
	if in.AutovacuumVacuumCostDelay != nil {
		in, out := &in.AutovacuumVacuumCostDelay, &out.AutovacuumVacuumCostDelay
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PGSubPGUserConfig.
func (in *PGSubPGUserConfig) DeepCopy() *PGSubPGUserConfig {
	if in == nil {
		return nil
	}
	out := new(PGSubPGUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PGUserConfig) DeepCopyInto(out *PGUserConfig) {
	*out = *in
	if in.BackupMinute != nil {
		in, out := &in.BackupMinute, &out.BackupMinute
		*out = new(int64)
		**out = **in
	}
	if in.BackupHour != nil {
		in, out := &in.BackupHour, &out.BackupHour
		*out = new(int64)
		**out = **in
	}
	in.Pglookout.DeepCopyInto(&out.Pglookout)
	if in.SharedBuffersPercentage != nil {
		in, out := &in.SharedBuffersPercentage, &out.SharedBuffersPercentage
		*out = new(int64)
		**out = **in
	}
	in.Timescaledb.DeepCopyInto(&out.Timescaledb)
	in.Pg.DeepCopyInto(&out.Pg)
	if in.IpFilter != nil {
		in, out := &in.IpFilter, &out.IpFilter
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	in.Pgbouncer.DeepCopyInto(&out.Pgbouncer)
	in.Migration.DeepCopyInto(&out.Migration)
	in.PrivateAccess.DeepCopyInto(&out.PrivateAccess)
	in.PublicAccess.DeepCopyInto(&out.PublicAccess)
	if in.WorkMem != nil {
		in, out := &in.WorkMem, &out.WorkMem
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PGUserConfig.
func (in *PGUserConfig) DeepCopy() *PGUserConfig {
	if in == nil {
		return nil
	}
	out := new(PGUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgLookoutUserConfig) DeepCopyInto(out *PgLookoutUserConfig) {
	*out = *in
	if in.MaxFailoverReplicationTimeLag != nil {
		in, out := &in.MaxFailoverReplicationTimeLag, &out.MaxFailoverReplicationTimeLag
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgLookoutUserConfig.
func (in *PgLookoutUserConfig) DeepCopy() *PgLookoutUserConfig {
	if in == nil {
		return nil
	}
	out := new(PgLookoutUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgbouncerUserConfig) DeepCopyInto(out *PgbouncerUserConfig) {
	*out = *in
	if in.IgnoreStartupParameters != nil {
		in, out := &in.IgnoreStartupParameters, &out.IgnoreStartupParameters
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ServerResetQueryAlways != nil {
		in, out := &in.ServerResetQueryAlways, &out.ServerResetQueryAlways
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgbouncerUserConfig.
func (in *PgbouncerUserConfig) DeepCopy() *PgbouncerUserConfig {
	if in == nil {
		return nil
	}
	out := new(PgbouncerUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PrivateAccessUserConfig) DeepCopyInto(out *PrivateAccessUserConfig) {
	*out = *in
	if in.Pg != nil {
		in, out := &in.Pg, &out.Pg
		*out = new(bool)
		**out = **in
	}
	if in.Pgbouncer != nil {
		in, out := &in.Pgbouncer, &out.Pgbouncer
		*out = new(bool)
		**out = **in
	}
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PrivateAccessUserConfig.
func (in *PrivateAccessUserConfig) DeepCopy() *PrivateAccessUserConfig {
	if in == nil {
		return nil
	}
	out := new(PrivateAccessUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Project) DeepCopyInto(out *Project) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Project.
func (in *Project) DeepCopy() *Project {
	if in == nil {
		return nil
	}
	out := new(Project)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Project) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectList) DeepCopyInto(out *ProjectList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Project, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectList.
func (in *ProjectList) DeepCopy() *ProjectList {
	if in == nil {
		return nil
	}
	out := new(ProjectList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectSpec) DeepCopyInto(out *ProjectSpec) {
	*out = *in
	if in.BillingEmails != nil {
		in, out := &in.BillingEmails, &out.BillingEmails
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.TechnicalEmails != nil {
		in, out := &in.TechnicalEmails, &out.TechnicalEmails
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectSpec.
func (in *ProjectSpec) DeepCopy() *ProjectSpec {
	if in == nil {
		return nil
	}
	out := new(ProjectSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectStatus) DeepCopyInto(out *ProjectStatus) {
	*out = *in
	if in.BillingEmails != nil {
		in, out := &in.BillingEmails, &out.BillingEmails
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.TechnicalEmails != nil {
		in, out := &in.TechnicalEmails, &out.TechnicalEmails
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectStatus.
func (in *ProjectStatus) DeepCopy() *ProjectStatus {
	if in == nil {
		return nil
	}
	out := new(ProjectStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPC) DeepCopyInto(out *ProjectVPC) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPC.
func (in *ProjectVPC) DeepCopy() *ProjectVPC {
	if in == nil {
		return nil
	}
	out := new(ProjectVPC)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectVPC) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPCList) DeepCopyInto(out *ProjectVPCList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ProjectVPC, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPCList.
func (in *ProjectVPCList) DeepCopy() *ProjectVPCList {
	if in == nil {
		return nil
	}
	out := new(ProjectVPCList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectVPCList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPCSpec) DeepCopyInto(out *ProjectVPCSpec) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPCSpec.
func (in *ProjectVPCSpec) DeepCopy() *ProjectVPCSpec {
	if in == nil {
		return nil
	}
	out := new(ProjectVPCSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectVPCStatus) DeepCopyInto(out *ProjectVPCStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectVPCStatus.
func (in *ProjectVPCStatus) DeepCopy() *ProjectVPCStatus {
	if in == nil {
		return nil
	}
	out := new(ProjectVPCStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PublicAccessUserConfig) DeepCopyInto(out *PublicAccessUserConfig) {
	*out = *in
	if in.Pg != nil {
		in, out := &in.Pg, &out.Pg
		*out = new(bool)
		**out = **in
	}
	if in.Pgbouncer != nil {
		in, out := &in.Pgbouncer, &out.Pgbouncer
		*out = new(bool)
		**out = **in
	}
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PublicAccessUserConfig.
func (in *PublicAccessUserConfig) DeepCopy() *PublicAccessUserConfig {
	if in == nil {
		return nil
	}
	out := new(PublicAccessUserConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUser) DeepCopyInto(out *ServiceUser) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUser.
func (in *ServiceUser) DeepCopy() *ServiceUser {
	if in == nil {
		return nil
	}
	out := new(ServiceUser)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceUser) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUserList) DeepCopyInto(out *ServiceUserList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ServiceUser, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUserList.
func (in *ServiceUserList) DeepCopy() *ServiceUserList {
	if in == nil {
		return nil
	}
	out := new(ServiceUserList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceUserList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUserSpec) DeepCopyInto(out *ServiceUserSpec) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUserSpec.
func (in *ServiceUserSpec) DeepCopy() *ServiceUserSpec {
	if in == nil {
		return nil
	}
	out := new(ServiceUserSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceUserStatus) DeepCopyInto(out *ServiceUserStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceUserStatus.
func (in *ServiceUserStatus) DeepCopy() *ServiceUserStatus {
	if in == nil {
		return nil
	}
	out := new(ServiceUserStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TimescaledbUserConfig) DeepCopyInto(out *TimescaledbUserConfig) {
	*out = *in
	if in.MaxBackgroundWorkers != nil {
		in, out := &in.MaxBackgroundWorkers, &out.MaxBackgroundWorkers
		*out = new(int64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TimescaledbUserConfig.
func (in *TimescaledbUserConfig) DeepCopy() *TimescaledbUserConfig {
	if in == nil {
		return nil
	}
	out := new(TimescaledbUserConfig)
	in.DeepCopyInto(out)
	return out
}
